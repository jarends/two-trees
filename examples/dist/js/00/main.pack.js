(function(pack)
{
    var win = window,
        process = win.process || (win.process = {}),
        env     = process.env || (process.env = {}),
        cfg     = {
        index:      0,
        total:      1,
        startIndex: 0,
        type:       'register::0.10729487312188812_1503225071205',
        path:       '/Users/JOA/Projects/workspaces/my/two-trees/examples/dist/js/00/main.js',
        pack:       pack
    };
    env.NODE_ENV = env.NODE_ENV || 'development'
    var packer = // Generated by CoffeeScript 1.12.6
(function() {
  var Pack;

  Pack = (function() {
    function Pack() {}

    Pack.prototype.init = function(cfg) {
      this.cfg = cfg;
      this.mainIndex = this.cfg.startIndex;
      this.map = {};
      this.chunks = {};
      this.prepare();
      if (this.cfg.total === 1) {
        this.start();
      }
      return null;
    };

    Pack.prototype.prepare = function() {
      var pack;
      this.startTime = Date.now();
      this.registered = 1;
      pack = this.cfg.pack;
      this.getModule = (function(_this) {
        return function(index, chunk) {
          var m, r;
          if (chunk) {
            return _this.getChunk(index, chunk);
          }
          m = _this.map[index];
          if (m) {
            return m.exports;
          }
          m = _this.map[index] = {
            require: _this.getModule,
            exports: {}
          };
          r = pack[index];
          if (r) {
            r(m, m.exports, m.require);
            return m.exports;
          } else {
            console.log("Error requiring '" + index + "': module doesn't exist");
          }
          return null;
        };
      })(this);
      document.addEventListener(this.cfg.type, (function(_this) {
        return function(e) {
          return _this.handleEvent(e);
        };
      })(this));
      return null;
    };

    Pack.prototype.getChunk = function(index, chunk) {
      var chunks, loader, resolve, resolver, script;
      chunks = this.chunks[chunk];
      if (this.map[index]) {
        resolver = (function(_this) {
          return function(clazz) {
            return new Promise(function(r) {
              var m;
              m = _this.getModule(index);
              if (clazz) {
                r(m[clazz]);
              } else {
                r(m);
              }
              return null;
            });
          };
        })(this);
      } else {
        if (!chunks) {
          chunks = this.chunks[chunk] = [];
          script = document.createElement('script');
          script.src = chunk;
          document.body.appendChild(script);
        }
        loader = {};
        resolve = (function(_this) {
          return function() {
            var clazz, m;
            clazz = loader.clazz;
            m = _this.getModule(index);
            if (clazz) {
              return loader.r(m[clazz]);
            } else {
              return loader.r(m);
            }
          };
        })(this);
        loader.resolve = resolve;
        chunks.push(loader);
        resolver = function(clazz) {
          loader.clazz = clazz;
          return new Promise(function(r) {
            return loader.r = r;
          });
        };
      }
      return resolver;
    };

    Pack.prototype.start = function() {
      this.getModule(this.mainIndex);
      return null;
    };

    Pack.prototype.addPack = function(pack) {
      var key, value;
      for (key in pack) {
        value = pack[key];
        if (!this.cfg.pack[key]) {
          this.cfg.pack[key] = value;
        } else {
          console.log("Error adding module: module '" + key + "' already exists");
        }
      }
      return null;
    };

    Pack.prototype.handleEvent = function(e) {
      var chunk, chunks, detail, i, len, loader, pack;
      detail = e.detail;
      if (detail) {
        detail.registered = true;
        pack = detail.pack;
        if (pack) {
          null;
          this.addPack(pack);
        } else {
          console.log("Error adding pack: pack doesn't exists in details: ", detail);
        }
      } else {
        console.log("Error adding pack: detail doesn't exist in event: ", event);
      }
      chunk = detail.chunk;
      if (!chunk) {
        if (detail.index === 0) {
          this.mainIndex = detail.startIndex;
        }
        if (++this.registered === this.cfg.total) {
          this.start();
        }
      } else {
        chunks = this.chunks[chunk];
        if (chunks) {
          for (i = 0, len = chunks.length; i < len; i++) {
            loader = chunks[i];
            loader.resolve();
          }
        }
      }
      return null;
    };

    return Pack;

  })();

  return new Pack();

}).call(this);

    packer.init(cfg);
})({
// /Users/JOA/Projects/workspaces/my/two-trees/examples/dist/js/00/main.js
0: function(module, exports, require) {
module.id = 'js/00/main.js';
// Generated by CoffeeScript 1.12.6
(function() {
  var ViewNode, app;

  ViewNode = require(1).ViewNode;

  app = ViewNode.create('Hello World ;-)');

  app.appendTo(document.querySelector('.app'));

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/examples/dist/js/two-trees.js
1: function(module, exports, require) {
module.id = 'js/two-trees.js';
// Generated by CoffeeScript 1.12.6
(function() {
  module.exports = require(2);

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/index.js
2: function(module, exports, require) {
module.id = '../../index.js';
(function()
{
    module.exports = {
        DataTree:      require(3),
        ViewTree:      require(4),
        ViewNode:      require(5),
        CompNode:      require(6),
        utils:         require(9)
    };

}).call(this);

},
// /Users/JOA/Projects/workspaces/my/two-trees/src/js/data-tree.js
3: function(module, exports, require) {
module.id = '../../src/js/data-tree.js';
// Generated by CoffeeScript 1.12.6
(function() {
  var TreeTwo, __id__, addOwner, removeOwner;

  __id__ = 0;

  TreeTwo = (function() {
    function TreeTwo(root) {
      this.nodeMap = {};
      this.bindings = {};
      this.history = [];
      this.historyIndex = 0;
      if (root) {
        this.setRoot(root);
      }
    }

    TreeTwo.prototype.setRoot = function(obj) {
      this.rootNode = this.createNode(null, '/', obj);
      return this.root = obj;
    };

    TreeTwo.prototype.getRoot = function() {
      if (!this.rootNode) {
        return null;
      }
      return this.rootNode.value;
    };

    TreeTwo.prototype.has = function(obj) {
      return typeof obj === 'object' && this.nodeMap[obj.__node_id__] !== void 0;
    };

    TreeTwo.prototype.bind = function(obj, name, callback) {
      var error, node, paths;
      node = typeof obj === 'object' ? this.nodeMap[obj.__node_id__] : null;
      if (!node) {
        console.error(error = 'Error: object not part of this tree: ', obj);
        throw new Error(error);
      }
      paths = {};
      this.addPaths(node, name, null, (function(_this) {
        return function(path) {
          var callbacks;
          callbacks = _this.bindings[path] || (_this.bindings[path] = []);
          if (callbacks.indexOf(callback) === -1) {
            callbacks.push(callback);
            return paths[path] = callback;
          }
        };
      })(this));
      return paths;
    };

    TreeTwo.prototype.unbind = function(paths) {
      var callback, callbacks, index, path, total, unbound;
      unbound = total = 0;
      for (path in paths) {
        callback = paths[path];
        callbacks = this.bindings[path];
        ++total;
        if (callbacks) {
          index = callbacks.indexOf(callback);
          if (index > -1) {
            ++unbound;
            callbacks.splice(index, 1);
          }
          if (callbacks.length === 0) {
            delete this.bindings[path];
          }
        }
      }
      return unbound === total;
    };

    TreeTwo.prototype.update = function(obj, name) {
      var error, node;
      node = typeof obj === 'object' ? this.nodeMap[obj.__node_id__] : this.rootNode;
      if (!node) {
        console.error(error = 'Error: object not part of this tree: ', obj);
        throw new Error(error);
      }
      this.currentActions = [];
      this.currentPaths = {};
      this.updatedMap = {};
      if (name !== void 0) {
        this.updateProp(node, name);
      } else {
        this.updateNode(node);
      }
      if (this.currentActions.length) {
        if (this.historyIndex < this.history.length) {
          this.history.length = this.historyIndex;
        }
        this.history.push(this.currentActions);
        ++this.historyIndex;
        this.currentActions.paths = this.currentPaths;
        this.dispatchBindings(this.currentPaths);
      }
      this.currentPaths = null;
      return false;
    };

    TreeTwo.prototype.undo = function() {
      var action, actions, j, len;
      if (this.historyIndex > 0) {
        actions = this.history[--this.historyIndex];
        for (j = 0, len = actions.length; j < len; j++) {
          action = actions[j];
          action.undo();
        }
        this.dispatchBindings(actions.paths);
      } else {
        console.log('undo not possible!!! ', this.historyIndex);
      }
      return null;
    };

    TreeTwo.prototype.redo = function() {
      var action, actions, j, len;
      if (this.historyIndex < this.history.length) {
        actions = this.history[this.historyIndex++];
        for (j = 0, len = actions.length; j < len; j++) {
          action = actions[j];
          action.redo();
        }
        this.dispatchBindings(actions.paths);
      } else {
        console.log('redo not possible!!! ', this.historyIndex);
      }
      return null;
    };

    TreeTwo.prototype.dispatchBindings = function(paths) {
      var callback, callbacks, called, dispatched, j, k, len, len1, name, node, parts, path, pcallbacks, ppath, value;
      called = [];
      dispatched = false;
      for (path in paths) {
        node = paths[path];
        parts = path.split('/');
        name = parts.pop() || '';
        ppath = parts.join('/') + '/*';
        callbacks = this.bindings[path];
        pcallbacks = this.bindings[ppath];
        value = node.value;
        if (callbacks) {
          for (j = 0, len = callbacks.length; j < len; j++) {
            callback = callbacks[j];
            if (called.indexOf(callback) === -1) {
              callback(value[name], value, name, path);
              dispatched = true;
              called.push(callback);
            }
          }
        }
        if (pcallbacks) {
          for (k = 0, len1 = pcallbacks.length; k < len1; k++) {
            callback = pcallbacks[k];
            callback(value);
            dispatched = true;
          }
        }
      }
      return dispatched;
    };

    TreeTwo.prototype.createNode = function(owner, name, value) {
      var i, id, j, key, l, node, props, ref;
      if (value) {
        node = this.nodeMap[value.__node_id__];
      }
      if (!node) {
        id = ++__id__;
        node = {
          id: id,
          value: value,
          type: 'value',
          owners: {}
        };
        this.nodeMap[node.id] = node;
        if (owner) {
          this.addPaths(owner, name, this.currentPaths);
        }
        if (value) {
          if (value.constructor.name === 'Array') {
            Object.defineProperty(value, '__node_id__', {
              value: node.id,
              enumerable: false
            });
            node.type = 'array';
            node.props = props = [];
            l = value.length;
            for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              props[i] = this.createNode(node, i, value[i]);
            }
          } else if (value.constructor.name === 'Object') {
            Object.defineProperty(value, '__node_id__', {
              value: node.id,
              enumerable: false
            });
            node.type = 'object';
            node.props = props = {};
            for (key in value) {
              props[key] = this.createNode(node, key, value[key]);
            }
          }
        }
      }
      if (owner) {
        addOwner(node, owner, name);
      }
      return node;
    };

    TreeTwo.prototype.updateNode = function(node) {
      var i, j, key, keys, l, pl, props, ref, value, vl;
      if (this.updatedMap[node.id]) {
        return true;
      }
      this.updatedMap[node.id] = true;
      value = node.value;
      props = node.props;
      if (node.type === 'array') {
        pl = props.length;
        vl = value.length;
        l = pl > vl ? pl : vl;
        for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this.updateProp(node, i);
        }
        if (pl !== vl) {
          this.addChangeLengthAction(node, pl, vl);
          props.length = vl;
        }
      } else if (node.type === 'object') {
        keys = {};
        for (key in props) {
          keys[key] = true;
        }
        for (key in value) {
          keys[key] = true;
        }
        for (key in keys) {
          this.updateProp(node, key);
        }
      }
      return null;
    };

    TreeTwo.prototype.updateProp = function(node, name) {
      var child, next, type, value;
      child = node.props[name];
      value = node.value[name];
      if (!child && value === void 0) {
        console.error("Error: either old or new value must exist for property \"" + name + "\" of node: ", node);
        return false;
      }
      if (!child) {
        child = this.createNode(node, name, value);
        this.addCreateAction(child, node, name);
      } else if (value === void 0) {
        if (child.type !== 'value') {
          this.updateNode(child);
        }
        removeOwner(child, node, name);
        this.addRemoveAction(child, node, name);
      } else {
        if (child.value === value) {
          if (child.type !== 'value') {
            if (!this.updatedMap[child.id]) {
              this.updateNode(child);
            }
          } else {
            return false;
          }
        } else {
          type = 'value';
          if (value) {
            if (value.constructor.name === 'Array') {
              type = 'array';
            } else if (value.constructor.name === 'Object') {
              type = 'object';
            }
          }
          if (type !== 'value' || type !== child.type) {
            removeOwner(child, node, name);
            next = this.createNode(node, name, value);
            this.addSwapAction(child, node, name, next);
          } else {
            this.addChangeValueAction(child, node, name, value);
            child.value = value;
          }
        }
      }
      return null;
    };

    TreeTwo.prototype.addCreateAction = function(node, owner, name) {
      this.addPaths(owner, name, this.currentPaths);
      this.currentActions.push({
        type: 'create',
        undo: function() {
          return removeOwner(node, owner, name);
        },
        redo: function() {
          return addOwner(node, owner, name);
        }
      });
      return null;
    };

    TreeTwo.prototype.addRemoveAction = function(node, owner, name) {
      this.addPaths(owner, name, this.currentPaths);
      this.currentActions.push({
        type: 'remove',
        undo: function() {
          return addOwner(node, owner, name);
        },
        redo: function() {
          return removeOwner(node, owner, name);
        }
      });
      return null;
    };

    TreeTwo.prototype.addSwapAction = function(node, owner, name, next) {
      this.addPaths(owner, name, this.currentPaths);
      this.currentActions.push({
        type: 'swap',
        undo: function() {
          removeOwner(next, owner, name);
          return addOwner(node, owner, name);
        },
        redo: function() {
          removeOwner(node, owner, name);
          return addOwner(next, owner, name);
        }
      });
      return null;
    };

    TreeTwo.prototype.addChangeValueAction = function(node, owner, name, newValue) {
      this.addPaths(owner, name, this.currentPaths);
      this.currentActions.push({
        type: 'changeValue',
        oldValue: node.value,
        undo: function() {
          node.value = this.oldValue;
          return owner.value[name] = this.oldValue;
        },
        redo: function() {
          node.value = newValue;
          return owner.value[name] = newValue;
        }
      });
      return null;
    };

    TreeTwo.prototype.addChangeLengthAction = function(node, oldLength, newLength) {
      this.currentActions.push({
        type: 'changeLength',
        undo: function() {
          return node.value.length = node.props.length = oldLength;
        },
        redo: function() {
          return node.value.length = node.props.length = newLength;
        }
      });
      return null;
    };

    TreeTwo.prototype.addPaths = function(node, path, paths, callback, root) {
      var id, n, names, owner, ref;
      path = path === null || path === void 0 ? '' : path + '';
      if (path) {
        path = '/' + path;
      }
      paths = paths || {};
      root = root || node;
      if (node === this.rootNode) {
        paths[path] = root;
        if (callback) {
          callback(path);
        }
      } else {
        ref = node.owners;
        for (id in ref) {
          names = ref[id];
          owner = this.nodeMap[id];
          for (n in names) {
            this.addPaths(owner, n + path, paths, callback, root);
          }
        }
      }
      return paths;
    };

    return TreeTwo;

  })();

  addOwner = function(node, owner, name) {
    var names, owners;
    owners = node.owners;
    names = owners[owner.id] || (owners[owner.id] = {});
    if (names[name]) {
      return null;
    }
    names[name] = true;
    owner.props[name] = node;
    owner.value[name] = node.value;
    return null;
  };

  removeOwner = function(node, owner, name) {
    var names, owners;
    owners = node.owners;
    names = owners[owner.id];
    if (!names || !names[name]) {
      return null;
    }
    delete names[name];
    delete owner.props[name];
    delete owner.value[name];
    return null;
  };

  if (Object.defineProperty === void 0) {
    Object.defineProperty = function(obj, name, data) {
      return obj[name] = data.value;
    };
  }

  if (typeof module !== 'undefined') {
    module.exports = TreeTwo;
  }

  if (typeof window !== 'undefined') {
    window.TreeTwo = TreeTwo;
  } else {
    this.TreeTwo = TreeTwo;
  }

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/src/js/view-tree.js
4: function(module, exports, require) {
module.id = '../../src/js/view-tree.js';
// Generated by CoffeeScript 1.12.6
(function() {
  module.exports = require(5);

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/src/js/view-node.js
5: function(module, exports, require) {
module.id = '../../src/js/view-node.js';
// Generated by CoffeeScript 1.12.6
(function() {
  var ViewNode, _, __id__, callResize, checkDom, classMap, create, dirty, dirtyMap, dispose, domList, handleResize, map, nodeMap, performUpdate, rafTimeout, unmap, update,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require(9);

  __id__ = 0;

  nodeMap = {};

  dirtyMap = {};

  classMap = {};

  domList = [];

  dirty = false;

  rafTimeout = null;

  ViewNode = (function() {
    ViewNode.DEBUG = false;

    ViewNode.DEFAULT_CLASS = ViewNode;

    ViewNode.CHECK_DOM = true;

    ViewNode.TAG_KIND = 1;

    ViewNode.TEXT_KIND = 3;

    ViewNode.IGNORES = {
      tag: true,
      clazz: true,
      inject: true,
      keep: true,
      text: true,
      child: true,
      className: true,
      style: true,
      children: true,
      bindings: true
    };

    function ViewNode(cfg) {
      this.update = bind(this.update, this);
      var inject, key, value;
      this.parent = null;
      this.depth = 0;
      this.keep = false;
      this.__id__ = ++__id__;
      nodeMap[this.__id__] = this;
      if (_.isNot(this.inject) && cfg && cfg.inject) {
        inject = this.inject = cfg.inject;
        for (key in inject) {
          value = inject[key];
          this[key] = value;
        }
      }
      this.updateCfg(cfg);
      this.populate();
    }

    ViewNode.prototype.appendTo = function(dom) {
      if (this.parent) {
        throw new Error('Please remove node from parent node before adding to the real dom.');
      }
      if (ViewNode.CHECK_DOM) {
        checkDom(dom);
      }
      dom.appendChild(this.view);
      this.onMount();
      this.onAddedToDom();
      return this;
    };

    ViewNode.prototype.behind = function(dom) {
      var next, parent;
      if (this.parent) {
        throw new Error('Please remove node from parent node before adding to the real dom.');
      }
      parent = dom.parentNode;
      next = dom.nextSibling;
      if (ViewNode.CHECK_DOM) {
        checkDom(parent);
      }
      if (next) {
        parent.insertBefore(this.view, next);
      } else {
        parent.appendChild(this.view);
      }
      this.onMount();
      this.onAddedToDom();
      return this;
    };

    ViewNode.prototype.before = function(dom) {
      var parent;
      if (this.parent) {
        throw new Error('Please remove node from parent node before adding to the real dom.');
      }
      parent = dom.parentNode;
      if (ViewNode.CHECK_DOM) {
        checkDom(parent);
      }
      parent.insertBefore(this.view, dom);
      this.onMount();
      this.onAddedToDom();
      return this;
    };

    ViewNode.prototype.replace = function(dom) {
      var parent;
      if (this.parent) {
        throw new Error('Please remove node from parent node before adding to the real dom.');
      }
      parent = dom.parentNode;
      if (ViewNode.CHECK_DOM) {
        checkDom(parent);
        checkDom(dom);
      }
      parent.replaceChild(this.view, dom);
      this.onMount();
      this.onRemovedFromDom();
      return this;
    };

    ViewNode.prototype.remove = function() {
      var parent;
      if (this.parent) {
        throw new Error('Please remove node from parent node instead of removing from real dom.');
      }
      parent = node.view.parentNode;
      if (ViewNode.CHECK_DOM) {
        checkDom(parent);
      }
      parent.removeChild(this.view);
      this.onUnmount();
      return this;
    };

    ViewNode.prototype.updateCfg = function(cfg1) {
      this.cfg = cfg1;
      return true;
    };

    ViewNode.prototype.update = function() {
      return update(this);
    };

    ViewNode.prototype.render = function() {
      return this.cfg;
    };

    ViewNode.prototype.onMount = function() {};

    ViewNode.prototype.onUnmount = function() {
      return this.keep;
    };

    ViewNode.prototype.onAddedToDom = function() {
      var child, j, len, ref;
      if (this.children) {
        ref = this.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          child.onAddedToDom();
        }
      }
      return this;
    };

    ViewNode.prototype.onRemovedFromDom = function() {
      var child, j, len, ref;
      if (this.children) {
        ref = this.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          child.onRemovedFromDom();
        }
      }
      return this;
    };

    ViewNode.prototype.populate = function() {
      var cfg, tag, text;
      if (this.view) {
        throw new Error("View already exists");
      }
      if (_.isNot(cfg = this.render())) {
        throw new Error("A view for an empty cfg can't be created.");
      }
      if (_.isSimple(cfg)) {
        this.createTextView({
          text: cfg
        });
      } else if (_.isString(tag = cfg.tag)) {
        this.createTagView(cfg);
      } else if (_.isDom(cfg)) {
        this.createTagFromDom(null, cfg);
      } else if (_.isDomText(cfg)) {
        this.createTextFromDom(null, cfg);
      } else if (_.isDom(tag)) {
        this.createTagFromDom(cfg, tag);
      } else if (_.isDomText(tag)) {
        this.createTextFromDom(cfg, tag);
      } else if (_.isSimple(text = cfg.text) || _.isFunc(text)) {
        this.createTextView(cfg);
      } else {
        if (_.extendsNode(tag)) {
          throw new Error("A tag must be a string or a HTMLElement, you specified a ViewNode class.");
        }
        throw new Error("A tag must be a string or a HTMLElement.");
      }
      if (ViewNode.CHECK_DOM) {
        domList.push(this.view);
      }
      return this;
    };

    ViewNode.prototype.createTextView = function(cfg) {
      var text;
      text = cfg.text;
      if (_.isFunc(text)) {
        text = text();
      }
      if (!_.isSimple(text)) {
        throw new Error("The text for a text node must be either a string, number or bool or a function returning one of these types.");
      }
      this.text = text + '';
      this.tag = cfg.tag = void 0;
      this.kind = ViewNode.TEXT_KIND;
      this.view = document.createTextNode(text);
      return this;
    };

    ViewNode.prototype.createTextFromDom = function(cfg, dom) {
      var text;
      if (ViewNode.CHECK_DOM) {
        checkDom(dom);
      }
      this.text = dom.nodeValue;
      this.tag = void 0;
      this.kind = ViewNode.TEXT_KIND;
      this.view = dom;
      if (cfg) {
        text = cfg.text;
        if (_.isNot(text)) {
          cfg.text = this.text;
        } else {
          if (_.isFunc(text)) {
            text = text();
          }
          if (!_.isSimple(text)) {
            throw new Error("The text for a text node must be either a string, number or bool or a function returning one of these types.");
          }
          this.text = dom.nodeValue = text + '';
        }
      } else {
        this.cfg = {
          text: this.text + ''
        };
      }
      this.cfg.tag = void 0;
      return this;
    };

    ViewNode.prototype.createTagView = function(cfg) {
      this.tag = cfg.tag;
      this.kind = ViewNode.TAG_KIND;
      this.view = document.createElement(cfg.tag);
      this.updateProps(cfg);
      return this;
    };

    ViewNode.prototype.createTagFromDom = function(cfg, dom) {
      if (ViewNode.CHECK_DOM) {
        checkDom(dom);
      }
      this.tag = dom.nodeName.toLowerCase();
      this.kind = ViewNode.TAG_KIND;
      this.view = dom;
      if (!cfg) {
        this.cfg = {
          tag: this.tag
        };
      } else {
        this.updateProps(cfg);
      }
      return this;
    };

    ViewNode.prototype.updateNow = function() {
      var cfg;
      cfg = this.render();
      if (this.kind === ViewNode.TAG_KIND) {
        this.updateProps(cfg);
      } else {
        this.updateText(cfg);
      }
      return this;
    };

    ViewNode.prototype.updateText = function(cfg) {
      var text;
      if (!_.isString(text = cfg)) {
        if (!_.isString(text = cfg.text)) {
          if (_.isFunc(text)) {
            text = text();
          }
        }
      }
      text += '';
      if (this.text !== text) {
        this.text = this.view.nodeValue = text;
      }
      return this;
    };

    ViewNode.prototype.updateProps = function(cfg) {
      var attr, ignore, key, name, propMap, value;
      this.attrs = this.attrs || {};
      this.events = this.events || {};
      this.children = this.children || [];
      if (cfg.text !== void 0) {
        this.updateChildren([cfg.text]);
        if (ViewNode.DEBUG) {
          if (cfg.child !== void 0) {
            console.warn('child specified while text exists: ', cfg);
          }
          if (cfg.children !== void 0) {
            console.warn('children specified while text exists', cfg);
          }
        }
      } else if (cfg.child !== void 0) {
        this.updateChildren([cfg.child]);
        if (ViewNode.DEBUG) {
          if (cfg.children !== void 0) {
            console.warn('children specified while child exists', cfg);
          }
        }
      } else if (cfg.children !== void 0) {
        if (_.isFunc(cfg.children)) {
          this.updateChildren(cfg.children());
        } else {
          this.updateChildren(cfg.children);
        }
      } else if (this.children.length) {
        this.updateChildren([]);
      }
      if (cfg.className !== void 0 || this.attrs.className !== void 0) {
        this.updateClassName(cfg.className);
      }
      if (cfg.style !== void 0 || this.attrs.style !== void 0) {
        this.updateStyle(cfg.style);
      }
      propMap = {};
      for (key in cfg) {
        propMap[key] = true;
      }
      for (key in this.attrs) {
        propMap[key] = true;
      }
      for (key in this.events) {
        propMap[key] = true;
      }
      ignore = ViewNode.IGNORES;
      for (name in propMap) {
        if (ignore[name]) {
          continue;
        }
        attr = this.attrs[name];
        value = cfg[name];
        if (_.isBool(value) || (_.isNot(value) && _.isBool(attr))) {
          this.updateBool(value, name);
        } else {
          if (name[0] === 'o' && name[1] === 'n') {
            this.updateEvent(value, name);
          } else {
            if (_.isFunc(value)) {
              value = value();
            }
            if (_.isBool(value)) {
              this.updateBool(value, name);
            } else {
              this.updateAttr(value, name);
            }
          }
        }
      }
      return this;
    };

    ViewNode.prototype.updateAttr = function(value, name) {
      var view;
      this.attrs[name] = this.view.getAttribute(name);
      if (this.attrs[name] === value) {
        return;
      }
      view = this.view;
      if (value !== null && value !== void 0) {
        view.setAttribute(name, value);
        view[name] = value;
        this.attrs[name] = value;
      } else {
        view.removeAttribute(name);
        delete view[name];
        delete this.attrs[name];
      }
      return this;
    };

    ViewNode.prototype.updateBool = function(value, name) {
      var view;
      this.attrs[name] = this.view[name];
      if (this.attrs[name] === value) {
        return;
      }
      view = this.view;
      if (_.isNot(value)) {
        view.removeAttribute(name);
        view[name] = false;
        delete this.attrs[name];
      } else if (value === false) {
        view.removeAttribute(name);
        view[name] = false;
        this.attrs[name] = false;
      } else {
        view.setAttribute(name, '');
        view[name] = true;
        this.attrs[name] = true;
      }
      return this;
    };

    ViewNode.prototype.updateClassName = function(value) {
      if (_.isFunc(value)) {
        value = value();
      }
      this.attrs.className = this.view.className;
      if (this.attrs.className === value) {
        return;
      }
      if (value) {
        this.view.className = value;
        this.attrs.className = value;
      } else {
        this.view.className = void 0;
        delete this.attrs.className;
      }
      return this;
    };

    ViewNode.prototype.updateStyle = function(value) {
      var attrs, changed, css, key, name, prop, propMap, style, v, view;
      view = this.view;
      attrs = this.attrs;
      style = attrs.style;
      if (_.isFunc(value)) {
        value = value();
      }
      if (_.isNot(value)) {
        if (style !== value) {
          view.style.cssText = null;
          delete attrs.style;
        }
      } else if (_.isString(value)) {
        if (style !== value) {
          view.style.cssText = value;
          attrs.style = value;
        }
      } else {
        css = '';
        style = _.isObject(style) ? style : {};
        changed = false;
        propMap = {};
        for (key in style) {
          propMap[key] = true;
        }
        for (key in value) {
          propMap[key] = true;
        }
        for (name in propMap) {
          v = value[name];
          changed = changed || v !== style[name];
          style[name] = v;
          if (_.isNot(v)) {
            delete style[name];
          } else {
            prop = _.normalizeName(name);
            css += prop + ': ' + v + '; ';
          }
        }
        if (changed) {
          if (css.length) {
            css = css.slice(0, -1);
            view.style.cssText = css;
          } else {
            view.style.cssText = null;
            delete attrs.style;
          }
        }
      }
      return this;
    };

    ViewNode.prototype.updateEvent = function(callback, name) {
      var listener, type;
      type = _.normalizeEvent(name);
      listener = this.events[name];
      if (_.isString(callback)) {
        callback = this[name];
      }
      if (listener !== callback) {
        if (listener) {
          this.view.removeEventListener(type, listener);
          delete this.events[name];
        }
        if (callback) {
          this.view.addEventListener(type, callback);
          this.events[name] = callback;
        }
      }
      return this;
    };

    ViewNode.prototype.removeEvents = function() {
      var events, listener, name, type, view;
      events = this.events;
      if (!events) {
        return null;
      }
      view = this.view;
      for (name in events) {
        listener = events[name];
        type = _.normalizeEvent(name);
        if (listener) {
          view.removeEventListener(type, listener);
        }
      }
      this.events = {};
      return this;
    };

    ViewNode.prototype.updateChildren = function(cfgs) {
      var cfg, child, children, hasCfg, i, j, l, newL, oldL, ref;
      children = this.children;
      if (_.isSimple(cfgs)) {
        cfgs = [cfgs];
      }
      oldL = children.length;
      newL = cfgs.length;
      l = oldL > newL ? oldL : newL;
      for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        child = children[i];
        cfg = cfgs[i];
        if (_.isFunc(cfg)) {
          cfg = cfg();
        }
        hasCfg = cfg !== void 0 && cfg !== null;
        if (!child && !hasCfg) {
          throw new Error(("DOM ERROR: either child or cfg at index " + i + " must be defined. Got ") + child + ', ' + cfg);
        }
        if (!child && hasCfg) {
          this.addChild(cfg);
        } else if (child && !hasCfg) {
          this.removeChild(child);
        } else {
          this.changeChild(child, cfg);
        }
      }
      if (newL !== oldL && newL !== children.length) {
        children.length = newL;
      }
      return this;
    };

    ViewNode.prototype.addChild = function(childOrCfg) {
      var cfg, child, keep;
      cfg = childOrCfg;
      if (_.isNodeInstance(cfg)) {
        child = cfg;
        if (child.parent) {
          keep = child.keep;
          child.keep = true;
          child.parent.removeChild(child);
          child.keep = keep;
        }
      } else {
        if (!cfg.inject) {
          cfg.inject = this.inject;
        }
        child = create(cfg);
      }
      child.parent = this;
      child.depth = this.depth + 1;
      this.children.push(child);
      this.view.appendChild(child.view);
      child.onMount();
      return child;
    };

    ViewNode.prototype.removeChild = function(child) {
      this.view.removeChild(child.view);
      dispose(child);
      return child;
    };

    ViewNode.prototype.changeChild = function(child, cfg) {
      if (_.isNodeInstance(cfg)) {
        if (child === cfg) {
          child.updateNow();
        } else {
          child = this.replaceChild(child, cfg);
        }
      } else if (_.isString(child.tag)) {
        if (child.tag === cfg.tag || child.constructor === cfg.tag) {
          if (child.updateCfg(cfg)) {
            child.updateProps(child.render());
          }
        } else {
          child = this.replaceChild(child, cfg);
        }
      } else if (_.isSimple(child.text)) {
        if (_.isSimple(cfg) || _.isSimple(cfg.text)) {
          if (child.updateCfg(cfg)) {
            child.updateText(child.render());
          }
        } else {
          child = this.replaceChild(child, cfg);
        }
      } else {
        child = this.replaceChild(child, cfg);
      }
      return child;
    };

    ViewNode.prototype.replaceChild = function(child, newChildOrCfg) {
      var cfg, children, i, keep, view;
      cfg = newChildOrCfg;
      children = this.children;
      i = children.indexOf(child);
      view = child.view;
      this.disposeNode(child);
      if (_.isNodeInstance(cfg)) {
        child = cfg;
        if (child.parent) {
          keep = child.keep;
          child.keep = true;
          child.parent.removeChild(child);
          child.keep = keep;
        }
      } else {
        if (!cfg.inject) {
          cfg.inject = this.inject;
        }
        child = create(cfg);
      }
      children[i] = child;
      child.parent = this;
      child.depth = this.depth + 1;
      this.view.replaceChild(child.view, view);
      return child;
    };

    return ViewNode;

  })();

  checkDom = function(dom) {
    if (domList.indexOf(dom) > -1) {
      throw new Error('Dom element already controlled by another node.');
    }
    return dom;
  };

  create = function(cfg) {
    var clazz, dom, tag;
    if (!_.extendsNode(clazz = cfg.clazz || cfg.tag)) {
      clazz = null;
      if (_.isDom(dom = cfg) || _.isDom(dom = cfg.tag)) {
        tag = dom.nodeName.toLowerCase();
      }
      if (_.isString(tag = tag || cfg.tag)) {
        clazz = classMap[tag];
      }
    }
    clazz = clazz || ViewNode.DEFAULT_CLASS;
    return new clazz(cfg);
  };

  dispose = function(node) {
    var child, j, len, ref;
    if (node.onUnmount() !== true) {
      node.removeEvents();
      if (node.children && node.children.length) {
        ref = node.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          dispose(child);
        }
      }
      delete node.children;
      delete node.view;
      delete nodeMap[node.__id__];
    }
    node.parent = null;
    node.depth = void 0;
    return node;
  };

  update = function(node) {
    var id;
    id = node != null ? node.__id__ : void 0;
    if (!id) {
      throw new Error("Can't update node. ViewNode doesn't exist.");
    }
    if (!dirty) {
      window.cancelAnimationFrame(rafTimeout);
      rafTimeout = window.requestAnimationFrame(performUpdate);
    }
    dirtyMap[id] = true;
    dirty = true;
    return null;
  };

  performUpdate = function() {
    var id, j, len, n, node, nodes;
    window.cancelAnimationFrame(rafTimeout);
    dirty = false;
    nodes = [];
    for (id in dirtyMap) {
      if (n = nodeMap[id]) {
        nodes.push(n);
      }
    }
    nodes.sort(function(a, b) {
      return a.depth - b.depth;
    });
    for (j = 0, len = nodes.length; j < len; j++) {
      node = nodes[j];
      if (!node.view || !nodeMap[node.__id__] || !dirtyMap[node.__id__]) {
        continue;
      }
      node.updateNow();
    }
    dirtyMap = {};
    return null;
  };

  map = function(tag, clazz, overwrite) {
    if (overwrite == null) {
      overwrite = false;
    }
    if (_.isNot(classMap[tag]) || overwrite) {
      classMap[tag] = clazz;
    }
    return null;
  };

  unmap = function(tag) {
    delete classMap[tag];
    return null;
  };

  callResize = function(node) {
    var child, j, len, ref;
    if (node.onResize) {
      node.onResize();
    }
    if (node.children) {
      ref = node.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        callResize(child);
      }
    }
    return node;
  };

  handleResize = function() {
    var key, node;
    for (key in nodeMap) {
      node = nodeMap[key];
      if (!node.parent && node.view) {
        callResize(node);
      }
    }
    return null;
  };

  window.addEventListener('resize', handleResize);

  ViewNode.create = create;

  ViewNode.map = map;

  ViewNode.unmap = unmap;

  module.exports = ViewNode;

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/src/js/utils.js
9: function(module, exports, require) {
module.id = '../../src/js/utils.js';
// Generated by CoffeeScript 1.12.6
(function() {
  var extendsNode, getOrCall, isBool, isDom, isDomText, isFunc, isNodeInstance, isNot, isNumber, isObject, isSimple, isString, normalizeEvent, normalizeName;

  getOrCall = function(value) {
    if (isFunc(value)) {
      return value();
    } else {
      return value;
    }
  };

  isBool = function(value) {
    return typeof value === 'boolean';
  };

  isNumber = function(value) {
    return typeof value === 'number';
  };

  isString = function(value) {
    return typeof value === 'string';
  };

  isObject = function(value) {
    return typeof value === 'object';
  };

  isFunc = function(value) {
    return typeof value === 'function';
  };

  isDom = function(value) {
    return value && value.nodeType === 1;
  };

  isDomText = function(value) {
    return value && value.nodeType === 3;
  };

  isNot = function(value) {
    return value === null || value === void 0;
  };

  isSimple = function(value) {
    var t;
    return (t = typeof value) === 'string' || t === 'number' || t === 'boolean';
  };

  extendsNode = function(value) {
    return isFunc(value) && (isFunc(value.prototype.render) || value === ViewNode);
  };

  isNodeInstance = function(value) {
    return value && value.__id__ && value.render;
  };

  normalizeName = function(name) {
    return name.replace(/[A-Z]/g, function(name) {
      return '-' + name.toLowerCase();
    });
  };

  normalizeEvent = function(type) {
    type = type.slice(2);
    return type.charAt(0).toLowerCase() + normalizeName(type.slice(1));
  };

  module.exports = {
    getOrCall: getOrCall,
    isBool: isBool,
    isNumber: isNumber,
    isString: isString,
    isObject: isObject,
    isFunc: isFunc,
    isDom: isDom,
    isDomText: isDomText,
    isNot: isNot,
    isSimple: isSimple,
    extendsNode: extendsNode,
    normalizeName: normalizeName,
    normalizeEvent: normalizeEvent,
    isNodeInstance: isNodeInstance
  };

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/src/js/comp-node.js
6: function(module, exports, require) {
module.id = '../../src/js/comp-node.js';
// Generated by CoffeeScript 1.12.6
(function() {
  var CompNode, ViewNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ViewNode = require(5);

  CompNode = (function(superClass) {
    extend(CompNode, superClass);

    function CompNode(cfg) {
      var binding, bindings, i, len;
      CompNode.__super__.constructor.call(this, cfg);
      this.paths = [];
      if (typeof cfg === 'object') {
        if (!this.tree) {
          throw new Error("Tree not injected.");
        }
        if (bindings = cfg.bindings) {
          for (i = 0, len = bindings.length; i < len; i++) {
            binding = bindings[i];
            if (Array.isArray(binding)) {
              this.bind(binding[0], binding[1]);
            } else {
              this.bind(binding);
            }
          }
        }
      }
      this;
    }

    CompNode.prototype.onUnmount = function() {
      this.unbindAll();
      return CompNode.__super__.onUnmount.call(this);
    };

    CompNode.prototype.bind = function(obj, name, callback) {
      return this.paths.push(this.tree.bind(obj, name, callback || this.update));
    };

    CompNode.prototype.unbind = function(paths) {
      var index;
      index = this.paths.indexOf(paths);
      if (index === -1) {
        console.error('Paths not bound by this comp. paths = ', paths);
        throw new Error('Paths not bound by this comp.');
      }
      this.paths.splice(index, 1);
      return this.tree.unbind(paths);
    };

    CompNode.prototype.unbindAll = function() {
      var allUnbound, i, len, paths, ref;
      allUnbound = true;
      ref = this.paths;
      for (i = 0, len = ref.length; i < len; i++) {
        paths = ref[i];
        allUnbound = allUnbound && this.tree.unbind(paths);
      }
      this.paths = [];
      return allUnbound;
    };

    return CompNode;

  })(ViewNode);

  module.exports = CompNode;

}).call(this);


}
});
//# sourceMappingURL=main.pack.js.map