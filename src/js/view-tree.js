// Generated by CoffeeScript 1.12.6
(function() {
  var ViewNode, ViewTree, _, __id__, j, lastTime, len, vendor, vendors, viewTree,
    slice = [].slice;

  _ = require('./utils');

  __id__ = 0;


  /*
      creation:
          cfg = render()
          createView cfg
          updateText cfg or updateProps cfg
  
      update/performeUpdate:
          cfg = render()
          updateText cfg or updateProps cfg or @replaceChildNode
  
      update children:
          cfg from children
          if cfg is node
              cfg = node.render()
          updateText cfg or updateProps cfg or @replaceChildNode
  
  
      cfg in render (in simple nodes same cfg as in constructor)
          cfg is simple -> text node
          cfg is dom tag -> tag node
          cfg is dom text -> text node
  
          cfg.tag is
              dom tag -> tag node
              dom text -> text node
              string -> map lookup in create
              node class -> not allowed in constructor or render -> only in children
  
          cfg.text is -> text node
              simple
              function
  
      cfg in children
          same as cfg in render
          node instance
   */

  ViewTree = (function() {
    function ViewTree() {
      this.classMap = {};
      this.nodeMap = [];
      this.dirtyMap = {};
      this.cleanMap = {};
      this.domList = [];
      this.dirty = false;
      this.rafTimeout = null;
    }

    ViewTree.prototype.create = function(cfg) {
      var clazz, dom, tag;
      if (_.isNot(cfg)) {
        throw new Error("A node can't be created from empty cfg.");
      }
      if (!_.extendsNode(clazz = cfg.clazz || cfg.tag)) {
        clazz = null;
        if (_.isDom(dom = cfg) || _.isDom(dom = cfg.tag)) {
          tag = dom.nodeName.toLowerCase();
        }
        if (_.isString(tag = tag || cfg.tag)) {
          clazz = this.classMap[tag];
        }
      }
      clazz = clazz || ViewNode.DEFAULT_CLASS;
      return new clazz(cfg);
    };

    ViewTree.prototype.register = function(node, cfg) {
      var inject, key, value;
      node.parent = null;
      node.depth = 0;
      node.keep = false;
      if (node.__id__) {
        throw new Error('Node allready registered.');
      }
      node.__id__ = ++__id__;
      this.nodeMap[node.__id__] = node;
      if (_.isNot(node.__i__) && cfg.__i__) {
        inject = node.__i__ = cfg.__i__;
        for (key in inject) {
          value = inject[key];
          node[key] = value;
        }
      }
      return node;
    };

    ViewTree.prototype.updateNow = function(node, cfg) {
      cfg = cfg || node.render();
      if (!node.view) {
        cfg = node.createView(cfg);
      }
      if (_.isDomText(node.view)) {
        this.updateText(node, cfg);
      } else {
        this.updateProperties(node, cfg);
      }
      return node;
    };

    ViewTree.prototype.createView = function(node, cfg) {
      var tag;
      if (node.view) {
        throw new Error("View already exists");
      }
      if (_.isNot(cfg)) {
        throw new Error("A view for an empty cfg can't be created.");
      }
      switch (true) {
        case _.isSimple(cfg):
          cfg = this.createTextView(node, node.cfg = {
            text: cfg + ''
          });
          break;
        case _.isDom(cfg):
          cfg = this.createTagFromDom(node, null, cfg);
          break;
        case _.isDomText(cfg):
          cfg = this.createTextFromDom(node, null, cfg);
          break;
        default:
          tag = cfg.tag;
          switch (true) {
            case _.isNot(tag):
              cfg = this.createTextView(node, cfg);
              break;
            case _.isString(tag):
              cfg = this.createTagView(node, cfg);
              break;
            case _.isDom(tag):
              cfg = this.createTagFromDom(node, cfg, tag);
              break;
            case _.isDomText(tag):
              cfg = this.createTextFromDom(node, cfg, tag);
              break;
            default:
              if (_.extendsNode(tag)) {
                throw new Error("A tag must be a string or a HTMLElement, you specified a ViewNode class.");
              }
              throw new Error("A tag must be a string or a HTMLElement.");
          }
      }
      if (ViewNode.CHECK_DOM) {
        this.domList.push(node.view);
      }
      return cfg;
    };

    ViewTree.prototype.createTextView = function(node, cfg) {
      var text;
      text = cfg.text;
      if (_.isFunc(text)) {
        text = text();
      }
      if (!_.isSimple(text)) {
        throw new Error("The text for a text node must be a string, number or bool.");
      }
      node.text = text + '';
      node.tag = cfg.tag = void 0;
      node.kind = ViewNode.TEXT_KIND;
      node.view = document.createTextNode(text);
      return cfg;
    };

    ViewTree.prototype.createTextFromDom = function(node, cfg, dom) {
      var text;
      if (ViewNode.CHECK_DOM) {
        this.checkDom(dom);
      }
      node.text = dom.nodeValue;
      node.tag = void 0;
      node.kind = ViewNode.TEXT_KIND;
      node.view = dom;
      if (cfg) {
        text = cfg.text;
        if (_.isNot(text)) {
          cfg.text = node.text;
        } else {
          if (_.isFunc(text)) {
            text = text();
          }
          if (!_.isSimple(text)) {
            throw new Error("The text for a text node must be a string, number or bool.");
          }
          node.text = dom.nodeValue = text + '';
        }
      } else {
        cfg = node.cfg = {
          text: node.text + ''
        };
      }
      cfg.tag = void 0;
      return cfg;
    };

    ViewTree.prototype.createTagView = function(node, cfg) {
      node.tag = cfg.tag;
      node.kind = ViewNode.TAG_KIND;
      node.view = document.createElement(cfg.tag);
      return cfg;
    };

    ViewTree.prototype.createTagFromDom = function(node, cfg, dom) {
      if (ViewNode.CHECK_DOM) {
        this.checkDom(dom);
      }
      node.tag = dom.nodeName.toLowerCase();
      node.kind = ViewNode.TAG_KIND;
      node.view = dom;
      cfg = cfg || (node.cfg = {});
      cfg.tag = node.tag;
      return cfg;
    };

    ViewTree.prototype.update = function(node) {
      var id;
      id = node != null ? node.__id__ : void 0;
      if (!id) {
        throw new Error("Can't update node. ViewNode doesn't exist.");
      }
      if (!this.dirty) {
        window.cancelAnimationFrame(this.rafTimeout);
        this.rafTimeout = window.requestAnimationFrame((function(_this) {
          return function() {
            return _this.performUpdate();
          };
        })(this));
      }
      this.dirtyMap[id] = true;
      this.dirty = true;
      return null;
    };

    ViewTree.prototype.performUpdate = function() {
      var cfg, display, id, j, len, n, node, nodes;
      window.cancelAnimationFrame(this.rafTimeout);
      this.dirty = false;
      this.cleanMap = {};
      nodes = [];
      for (id in this.dirtyMap) {
        if (n = this.nodeMap[id]) {
          nodes.push(n);
        }
      }
      nodes.sort(function(a, b) {
        return a.depth - b.depth;
      });
      for (j = 0, len = nodes.length; j < len; j++) {
        node = nodes[j];
        if (!node.view || !this.nodeMap[node.__id__] || this.cleanMap[node.__id__]) {
          continue;
        }
        cfg = node.render();
        if (_.isNot(node.tag) && _.isNot(cfg.tag)) {
          this.updateText(node, cfg);
        } else if (!(node.tag === cfg.tag || node.constructor === cfg.tag)) {
          this.replaceChildNode(node, cfg);
        } else {
          display = node.view.style.display;
          node.view.style.display = 'none';
          this.updateProperties(node, cfg);
          if (node.view.style.display === 'none') {
            node.view.style.display = display;
          }
        }
      }
      this.dirtyMap = {};
      return null;
    };

    ViewTree.prototype.updateText = function(node, cfg) {
      var text;
      this.cleanMap[node.__id__] = true;
      text = _.isFunc(cfg.text) ? cfg.text() : _.isString(cfg) ? cfg : cfg.text;
      text = text + '';
      if (node.text !== text) {
        node.text = text;
        node.view.nodeValue = text;
      }
      return node;
    };

    ViewTree.prototype.updateProperties = function(node, cfg) {
      var attr, attrs, child, name, propMap, text, value;
      this.cleanMap[node.__id__] = true;
      if (_.isNodeInstance(cfg)) {
        cfg = cfg.render();
      }
      attrs = node.attrs || (node.attrs = {});
      propMap = Object.assign({}, attrs, node.events || {}, cfg);
      if (propMap.hasOwnProperty('text')) {
        if (_.isFunc(text = cfg.text)) {
          text = text();
        }
        if (_.isSimple(text)) {
          this.updateChildren(node, [text]);
        } else if (_.isDomText(text)) {
          this.updateChildren(node, [text]);
        }
        if (ViewNode.DEBUG) {
          if (cfg.hasOwnProperty('child')) {
            console.warn('child specified while text exists: ', cfg);
          }
          if (cfg.hasOwnProperty('children')) {
            console.warn('children specified while text exists', cfg);
          }
        }
      } else if (propMap.hasOwnProperty('child')) {
        if (_.isFunc(child = cfg.child)) {
          child = child();
        }
        this.updateChildren(node, [child]);
        if (ViewNode.DEBUG) {
          if (cfg.hasOwnProperty('children')) {
            console.warn('children specified while child exists', cfg);
          }
        }
      } else if (propMap.hasOwnProperty('children')) {
        this.updateChildren(node, cfg.children);
      } else if (node.children && node.children.length) {
        this.updateChildren(node);
      }
      if (propMap.hasOwnProperty('className')) {
        this.updateClass(node, cfg.className);
      }
      if (propMap.hasOwnProperty('style')) {
        this.updateStyle(node, cfg.style);
      }
      delete propMap.tag;
      delete propMap.clazz;
      delete propMap.__i__;
      delete propMap.keep;
      delete propMap.text;
      delete propMap.child;
      delete propMap.className;
      delete propMap.style;
      delete propMap.children;
      delete propMap.bindings;
      for (name in propMap) {
        attr = attrs[name];
        value = cfg[name];
        if (_.isBool(value) || (_.isNot(value) && _.isBool(attr))) {
          this.updateBool(node, value, name);
        } else {
          if (name[0] === 'o' && name[1] === 'n') {
            this.updateEvent(node, value, name);
          } else {
            if (_.isFunc(value)) {
              value = value();
            }
            if (_.isBool(value)) {
              this.updateBool(node, value, name);
            } else {
              this.updateAttr(node, value, name);
            }
          }
        }
      }
      return node;
    };

    ViewTree.prototype.updateAttr = function(node, value, name) {
      var view;
      node.attrs[name] = node.view.getAttribute(name);
      if (node.attrs[name] === value) {
        return;
      }
      view = node.view;
      if (value !== null && value !== void 0) {
        view.setAttribute(name, value);
        view[name] = value;
        node.attrs[name] = value;
      } else {
        view.removeAttribute(name);
        delete view[name];
        delete node.attrs[name];
      }
      return node;
    };

    ViewTree.prototype.updateBool = function(node, value, name) {
      var view;
      node.attrs[name] = node.view[name];
      if (node.attrs[name] === value) {
        return;
      }
      view = node.view;
      if (_.isNot(value)) {
        view.removeAttribute(name);
        view[name] = false;
        delete node.attrs[name];
      } else if (value === false) {
        view.removeAttribute(name);
        view[name] = false;
        node.attrs[name] = false;
      } else {
        view.setAttribute(name, '');
        view[name] = true;
        node.attrs[name] = true;
      }
      return node;
    };

    ViewTree.prototype.updateClass = function(node, value) {
      if (_.isFunc(value)) {
        value = value();
      }
      node.attrs.className = node.view.className;
      if (node.attrs.className === value) {
        return;
      }
      if (value) {
        node.view.className = value;
        node.attrs.className = value;
      } else {
        node.view.className = void 0;
        delete node.attrs.className;
      }
      return node;
    };

    ViewTree.prototype.updateStyle = function(node, style) {
      var attrs, changed, css, name, prop, propMap, sobj, value, view;
      view = node.view;
      attrs = node.attrs;
      sobj = attrs.style;
      if (_.isFunc(style)) {
        style = style();
      }
      if (_.isNot(style)) {
        view.style.cssText = null;
        delete attrs.style;
      } else if (_.isString(style)) {
        view.style.cssText = style;
        attrs.style = style;
      } else {
        css = '';
        sobj = _.isObject(sobj) ? sobj : {};
        changed = false;
        propMap = Object.assign({}, style, sobj);
        for (name in propMap) {
          value = style[name];
          if (value !== sobj[name]) {
            changed = true;
          }
          sobj[name] = value;
          if (_.isNot(value)) {
            delete sobj[name];
          } else {
            prop = _.normalizeName(name);
            css += prop + ': ' + value + '; ';
          }
        }
        if (changed) {
          if (css.length) {
            css = css.slice(0, -1);
            view.style.cssText = css;
            attrs.style = sobj;
          } else {
            view.style.cssText = null;
            delete attrs.style;
          }
        }
      }
      return node;
    };

    ViewTree.prototype.updateEvent = function(node, callback, name) {
      var events, listener, type, view;
      events = node.events || (node.events = {});
      view = node.view;
      type = _.normalizeEvent(name);
      listener = events[name];
      if (_.isString(callback)) {
        callback = node[name];
      }
      if (listener !== callback) {
        if (listener) {
          view.removeEventListener(type, listener);
          delete events[name];
        }
        if (callback) {
          view.addEventListener(type, callback);
          events[name] = callback;
        }
      }
      return node;
    };

    ViewTree.prototype.removeEvents = function(node) {
      var events, listener, name, type, view;
      events = node.events;
      if (!events) {
        return null;
      }
      view = node.view;
      for (name in events) {
        listener = events[name];
        type = _.normalizeEvent(name);
        if (listener) {
          view.removeEventListener(type, listener);
        }
        delete events[name];
      }
      node.events = null;
      return node;
    };

    ViewTree.prototype.updateChildren = function(node, cfgs) {
      var cfg, child, children, i, j, l, ref;
      children = node.children || (node.children = []);
      if (_.isFunc(cfgs)) {
        cfgs = cfgs();
      }
      cfgs = _.isString(cfgs) ? [cfgs] : cfgs || [];
      l = children.length > cfgs.length ? children.length : cfgs.length;
      for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        child = children[i];
        cfg = cfgs[i];
        if (_.isFunc(cfg)) {
          cfg = cfg();
        }
        if (!child && _.isNot(cfg)) {
          throw new Error(("DOM ERROR: either child or cfg at index " + i + " must be defined. Got ") + child + ', ' + cfg);
        }
        if (!child) {
          this.addChildNode(node, cfg);
        } else if (_.isNot(cfg)) {
          this.removeChildNode(child);
        } else {
          this.change(child, cfg);
        }
      }
      children.length = cfgs.length;
      return node;
    };

    ViewTree.prototype.change = function(node, cfg) {
      var needsUpdate;
      needsUpdate = node.updateCfg(cfg);
      if (node === cfg || node.constructor === cfg.tag) {
        if (needsUpdate) {
          this.updateProperties(node, node.render());
        }
      } else if (node.tag !== cfg.tag && (node.tag || cfg.tag) || _.isNodeInstance(cfg)) {
        this.replaceChildNode(node, cfg);
      } else if (!node.tag) {
        this.updateText(node, cfg);
      } else if (needsUpdate) {
        this.updateProperties(node, cfg);
      }
      return false;
    };

    ViewTree.prototype.addChildNode = function(node, cfg) {
      var child;
      if (_.isNodeInstance(cfg)) {
        child = cfg;
      } else {
        if (!cfg.__i__) {
          cfg.__i__ = node.__i__;
        }
        child = this.create(cfg);
      }
      node.children.push(child);
      node.view.appendChild(child.view);
      child.parent = node;
      child.depth = node.depth + 1;
      child.onMount();
      return node;
    };

    ViewTree.prototype.removeChildNode = function(child) {
      var node, view;
      node = child.parent;
      view = child.view;
      this.disposeNode(child);
      node.view.removeChild(view);
      return node;
    };

    ViewTree.prototype.replaceChildNode = function(child, cfg) {
      var children, i, node, view;
      node = child.parent;
      children = node.children;
      i = children.indexOf(child);
      view = child.view;
      this.disposeNode(child);
      if (_.isNodeInstance(cfg)) {
        child = cfg;
        cfg = child.render();
      } else {
        if (!cfg.__i__) {
          cfg.__i__ = node.__i__;
        }
        child = this.create(cfg);
      }
      children[i] = child;
      child.parent = node;
      child.depth = node.depth + 1;
      node.view.replaceChild(child.view, view);
      if (_.isSimple(cfg) || (!cfg.tag && (_.isSimple(cfg.text) || _.isFunc(cfg.text)))) {
        this.updateText(child, cfg);
      } else {
        this.updateProperties(child, cfg);
      }
      child.onMount();
      return node;
    };

    ViewTree.prototype.disposeNode = function(node) {
      var child, j, len, ref;
      if (node.onUnmount() !== true) {
        this.removeEvents(node);
        if (node.children && node.children.length) {
          ref = node.children;
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            this.disposeNode(child);
          }
        }
        delete node.children;
        delete node.view;
        delete this.nodeMap[node.__id__];
      }
      node.parent = null;
      node.depth = void 0;
      return node;
    };

    ViewTree.prototype.checkDom = function(dom) {
      if (this.domList.indexOf(dom) > -1) {
        throw new Error('Dom element already controlled by another node.');
      }
    };

    ViewTree.prototype.appendTo = function(node, dom) {
      if (ViewNode.CHECK_DOM) {
        this.checkDom(dom);
      }
      return dom.appendChild(node.view);
    };

    ViewTree.prototype.behind = function(node, dom) {
      var next, parent;
      parent = dom.parentNode;
      next = dom.nextSibling;
      if (ViewNode.CHECK_DOM) {
        this.checkDom(parent);
      }
      if (next) {
        return parent.insertBefore(node.view, next);
      } else {
        return parent.appendChild(node.view);
      }
    };

    ViewTree.prototype.before = function(node, dom) {
      var parent;
      parent = dom.parentNode;
      if (ViewNode.CHECK_DOM) {
        this.checkDom(parent);
      }
      return parent.insertBefore(node.view, dom);
    };

    ViewTree.prototype.replace = function(node, dom) {
      var parent;
      parent = dom.parentNode;
      if (ViewNode.CHECK_DOM) {
        this.checkDom(parent);
        this.checkDom(dom);
      }
      return parent.replaceChild(node.view, dom);
    };

    ViewTree.prototype.remove = function(node) {
      var parent;
      parent = node.view.parentNode;
      if (ViewNode.CHECK_DOM) {
        this.checkDom(parent);
      }
      return parent.removeChild(node.view);
    };

    ViewTree.prototype.addChild = function(node, child) {};

    ViewTree.prototype.addChildAt = function(node, child, index) {};

    ViewTree.prototype.removeChild = function(node, child) {};

    ViewTree.prototype.removeChildAt = function(node, index) {};

    ViewTree.prototype.map = function(tag, clazz, overwrite) {
      if (overwrite == null) {
        overwrite = false;
      }
      if (_.isNot(this.classMap[tag]) || overwrite) {
        this.classMap[tag] = clazz;
      }
      return null;
    };

    ViewTree.prototype.unmap = function(tag) {
      delete this.classMap[tag];
      return null;
    };

    return ViewTree;

  })();

  if (typeof window !== 'undefined') {
    lastTime = 0;
    vendors = ['webkit', 'moz'];
    for (j = 0, len = vendors.length; j < len; j++) {
      vendor = vendors[j];
      if (window.requestAnimationFrame) {
        break;
      }
      window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback) {
        var currTime, id, rAF, timeToCall;
        currTime = Date.now();
        timeToCall = Math.max(0, 16 - currTime + lastTime);
        rAF = function() {
          return callback(currTime + timeToCall);
        };
        id = window.setTimeout(rAF, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
        return null;
      };
    }
  }

  if (typeof Object.assign === 'undefined') {
    Object.assign = function() {
      var args, k, key, len1, src, target;
      target = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      for (k = 0, len1 = args.length; k < len1; k++) {
        src = args[k];
        for (key in src) {
          target[key] = src[key];
        }
      }
      return target;
    };
  }

  viewTree = new ViewTree();

  if (typeof module !== 'undefined') {
    module.exports = viewTree;
    ViewNode = require('./view-node');
  }

  if (typeof window !== 'undefined') {
    window.ViewTree = viewTree;
  } else {
    this.ViewTree = viewTree;
  }

}).call(this);

//# sourceMappingURL=view-tree.js.map
