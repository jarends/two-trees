(function(pack)
{
    var win = window,
        process = win.process || (win.process = {}),
        env     = process.env || (process.env = {}),
        cfg     = {
        index:      0,
        total:      1,
        startIndex: 0,
        type:       'register::0.48756901295027655_1501252643243',
        path:       '/Users/JOA/Projects/workspaces/my/two-trees/test/js/index.js',
        pack:       pack
    };
    env.NODE_ENV = env.NODE_ENV || 'development'
    var packer = // Generated by CoffeeScript 1.12.6
(function() {
  var Pack;

  Pack = (function() {
    function Pack() {}

    Pack.prototype.init = function(cfg) {
      this.cfg = cfg;
      this.mainIndex = this.cfg.startIndex;
      this.map = {};
      this.chunks = {};
      this.prepare();
      if (this.cfg.total === 1) {
        this.start();
      }
      return null;
    };

    Pack.prototype.prepare = function() {
      var pack;
      this.startTime = Date.now();
      this.registered = 1;
      pack = this.cfg.pack;
      this.getModule = (function(_this) {
        return function(index, chunk) {
          var m, r;
          if (chunk) {
            return _this.getChunk(index, chunk);
          }
          m = _this.map[index];
          if (m) {
            return m.exports;
          }
          m = _this.map[index] = {
            require: _this.getModule,
            exports: {}
          };
          r = pack[index];
          if (r) {
            r(m, m.exports, m.require);
            return m.exports;
          } else {
            console.log("Error requiring '" + index + "': module doesn't exist");
          }
          return null;
        };
      })(this);
      document.addEventListener(this.cfg.type, (function(_this) {
        return function(e) {
          return _this.handleEvent(e);
        };
      })(this));
      return null;
    };

    Pack.prototype.getChunk = function(index, chunk) {
      var chunks, loader, resolve, resolver, script;
      chunks = this.chunks[chunk];
      if (this.map[index]) {
        resolver = (function(_this) {
          return function(clazz) {
            return new Promise(function(r) {
              var m;
              m = _this.getModule(index);
              if (clazz) {
                r(m[clazz]);
              } else {
                r(m);
              }
              return null;
            });
          };
        })(this);
      } else {
        if (!chunks) {
          chunks = this.chunks[chunk] = [];
          script = document.createElement('script');
          script.src = chunk;
          document.body.appendChild(script);
        }
        loader = {};
        resolve = (function(_this) {
          return function() {
            var clazz, m;
            clazz = loader.clazz;
            m = _this.getModule(index);
            if (clazz) {
              return loader.r(m[clazz]);
            } else {
              return loader.r(m);
            }
          };
        })(this);
        loader.resolve = resolve;
        chunks.push(loader);
        resolver = function(clazz) {
          loader.clazz = clazz;
          return new Promise(function(r) {
            return loader.r = r;
          });
        };
      }
      return resolver;
    };

    Pack.prototype.start = function() {
      this.getModule(this.mainIndex);
      return null;
    };

    Pack.prototype.addPack = function(pack) {
      var key, value;
      for (key in pack) {
        value = pack[key];
        if (!this.cfg.pack[key]) {
          this.cfg.pack[key] = value;
        } else {
          console.log("Error adding module: module '" + key + "' already exists");
        }
      }
      return null;
    };

    Pack.prototype.handleEvent = function(e) {
      var chunk, chunks, detail, i, len, loader, pack;
      detail = e.detail;
      if (detail) {
        detail.registered = true;
        pack = detail.pack;
        if (pack) {
          null;
          this.addPack(pack);
        } else {
          console.log("Error adding pack: pack doesn't exists in details: ", detail);
        }
      } else {
        console.log("Error adding pack: detail doesn't exist in event: ", event);
      }
      chunk = detail.chunk;
      if (!chunk) {
        if (detail.index === 0) {
          this.mainIndex = detail.startIndex;
        }
        if (++this.registered === this.cfg.total) {
          this.start();
        }
      } else {
        chunks = this.chunks[chunk];
        if (chunks) {
          for (i = 0, len = chunks.length; i < len; i++) {
            loader = chunks[i];
            loader.resolve();
          }
        }
      }
      return null;
    };

    return Pack;

  })();

  return new Pack();

}).call(this);

    packer.init(cfg);
})({
// /Users/JOA/Projects/workspaces/my/two-trees/test/js/index.js
0: function(module, exports, require) {
module.id = 'js/index.js';
// Generated by CoffeeScript 1.12.6
(function() {
  require(3);

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/test/js/node.js
3: function(module, exports, require) {
module.id = 'js/node.js';
// Generated by CoffeeScript 1.12.6
(function() {
  var MyExtendedNode, MyTextNode1, MyTextNode2, MyValidNode, Node, expectAttr, expectBoolAttr, expectClass, expectExtends, expectValidTagNode, expectValidTextNode, getTag, getText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Node = require(4);

  getTag = function(tag) {
    return document.createElement(tag);
  };

  getText = function(text) {
    return document.createTextNode(text);
  };

  MyValidNode = (function(superClass) {
    extend(MyValidNode, superClass);

    function MyValidNode() {
      return MyValidNode.__super__.constructor.apply(this, arguments);
    }

    MyValidNode.prototype.render = function() {
      return {
        tag: 'div'
      };
    };

    return MyValidNode;

  })(Node);

  MyTextNode1 = (function(superClass) {
    extend(MyTextNode1, superClass);

    function MyTextNode1() {
      return MyTextNode1.__super__.constructor.apply(this, arguments);
    }

    MyTextNode1.prototype.render = function() {
      return 'text';
    };

    return MyTextNode1;

  })(Node);

  MyTextNode2 = (function(superClass) {
    extend(MyTextNode2, superClass);

    function MyTextNode2() {
      return MyTextNode2.__super__.constructor.apply(this, arguments);
    }

    MyTextNode2.prototype.render = function() {
      return {
        text: 'text'
      };
    };

    return MyTextNode2;

  })(Node);

  MyExtendedNode = (function(superClass) {
    extend(MyExtendedNode, superClass);

    function MyExtendedNode() {
      return MyExtendedNode.__super__.constructor.apply(this, arguments);
    }

    return MyExtendedNode;

  })(Node);

  expectClass = function(node, clazz) {
    return expect(node.constructor).to.equal(clazz);
  };

  expectExtends = function(node, clazz) {
    return expect(node).to.be["instanceof"](clazz);
  };

  expectValidTextNode = function(node, clazz, text) {
    expectClass(node, clazz);
    expectExtends(node.view, Text);
    expect(node.view.nodeValue).to.equal(text + '');
    return expect(node.text).to.equal(text);
  };

  expectValidTagNode = function(node, clazz, tag) {
    expectClass(node, clazz);
    expectExtends(node.view, HTMLElement);
    expect(node.view.nodeName.toLowerCase()).to.equal(tag);
    return expect(node.tag).to.equal(tag);
  };

  expectAttr = function(node, name, value) {
    expectExtends(node.view, HTMLElement);
    value = Node.getOrCall(value);
    expect(node.attrs[name]).to.equal(value);
    return expect(node.view.getAttribute(name)).to.equal(value + '');
  };

  expectBoolAttr = function(node, name, value) {
    expectExtends(node.view, HTMLElement);
    value = Node.getOrCall(value);
    expect(node.attrs[name]).to.equal(value);
    if (value === true) {
      expect(node.view.getAttribute(name)).to.equal('');
      return expect(node.view[name]).to.equal(true);
    } else {
      expect(node.view.getAttribute(name)).to.equal(null);
      return expect(node.view[name]).to.equal(false);
    }
  };

  describe('new Node', function() {
    it("should return a valid text node, if cfg = 'text'", function() {
      return expectValidTextNode(new Node('text'), Node, 'text');
    });
    it("should return a valid text node, if cfg = Text", function() {
      return expectValidTextNode(new Node(getText('text')), Node, 'text');
    });
    it("should return a valid text node, if cfg.text = 'text'", function() {
      return expectValidTextNode(new Node({
        text: 'text'
      }), Node, 'text');
    });
    it("should return a valid text node, if cfg.tag = Text", function() {
      return expectValidTextNode(new Node({
        tag: getText('text')
      }), Node, 'text');
    });
    it("should return a valid tag node, if cfg = HTMLELement", function() {
      return expectValidTagNode(new Node(getTag('div')), Node, 'div');
    });
    it("should return a valid tag node, if cfg.tag = 'div'", function() {
      return expectValidTagNode(new Node({
        tag: 'div'
      }), Node, 'div');
    });
    it("should return a valid tag node, if cfg.tag = HTMLELement", function() {
      return expectValidTagNode(new Node({
        tag: getTag('div')
      }), Node, 'div');
    });
    it("should throw an error, if cfg = null", function() {
      return expect(function() {
        return new Node();
      }).to["throw"]();
    });
    it("should throw an error, if neither tag nor text are set", function() {
      return expect(function() {
        return new Node({});
      }).to["throw"]();
    });
    it("should throw an error, if cfg.tag is invalid", function() {
      expect(function() {
        return new Node({
          tag: 1
        });
      }).to["throw"]();
      expect(function() {
        return new Node({
          tag: true
        });
      }).to["throw"]();
      expect(function() {
        return new Node({
          tag: {}
        });
      }).to["throw"]();
      expect(function() {
        return new Node({
          tag: []
        });
      }).to["throw"]();
      expect(function() {
        return new Node({
          tag: function() {}
        });
      }).to["throw"]();
      return expect(function() {
        return new Node({
          tag: Node
        });
      }).to["throw"]();
    });
    it("should throw an error, if cfg.text is invalid", function() {
      expect(function() {
        return new Node({
          text: null
        });
      }).to["throw"]();
      expect(function() {
        return new Node({
          text: {}
        });
      }).to["throw"]();
      expect(function() {
        return new Node({
          text: []
        });
      }).to["throw"]();
      expect(function() {
        return new Node({
          text: function() {}
        });
      }).to["throw"]();
      expect(function() {
        return new Node({
          text: function() {
            return {};
          }
        });
      }).to["throw"]();
      return expect(function() {
        return new Node({
          text: function() {
            return [];
          }
        });
      }).to["throw"]();
    });
    it("should not throw an error, if cfg.text is valid", function() {
      expect(function() {
        return expectValidTextNode(new Node({
          text: ''
        }), Node, '');
      }).to.not["throw"]();
      expect(function() {
        return expectValidTextNode(new Node({
          text: 1
        }), Node, 1);
      }).to.not["throw"]();
      expect(function() {
        return expectValidTextNode(new Node({
          text: true
        }), Node, true);
      }).to.not["throw"]();
      expect(function() {
        return expectValidTextNode(new Node({
          text: function() {
            return '';
          }
        }), Node, '');
      }).to.not["throw"]();
      expect(function() {
        return expectValidTextNode(new Node({
          text: function() {
            return 1;
          }
        }), Node, 1);
      }).to.not["throw"]();
      return expect(function() {
        return expectValidTextNode(new Node({
          text: function() {
            return true;
          }
        }), Node, true);
      }).to.not["throw"]();
    });
    it("should create a attr title = 'my title'", function() {
      var cfg, node;
      cfg = {
        tag: 'div',
        title: 'my title'
      };
      expectValidTagNode(node = new Node(cfg), Node, 'div');
      return expectAttr(node, 'title', 'my title');
    });
    it("should create a bool attr disabled = true", function() {
      var cfg, node;
      cfg = {
        tag: 'div',
        disabled: true
      };
      expectValidTagNode(node = new Node(cfg), Node, 'div');
      return expectBoolAttr(node, 'disabled', true);
    });
    it("should create a bool attr disabled = false", function() {
      var cfg, node;
      cfg = {
        tag: 'div',
        disabled: false
      };
      expectValidTagNode(node = new Node(cfg), Node, 'div');
      return expectBoolAttr(node, 'disabled', false);
    });
    return it("should create a bool attr disabled = false", function() {
      var cfg, node;
      cfg = {
        tag: 'div',
        disabled: false
      };
      expectValidTagNode(node = new Node(cfg), Node, 'div');
      return expectBoolAttr(node, 'disabled', false);
    });
  });

  describe('Node', function() {
    return describe('.create', function() {
      it("should return a valid text node, if cfg = 'text'", function() {
        return expectValidTextNode(Node.create('text'), Node, 'text');
      });
      it("should return a valid text node, if cfg = Text", function() {
        return expectValidTextNode(Node.create(getText('text')), Node, 'text');
      });
      it("should return a valid text node, if cfg.text = 'text'", function() {
        return expectValidTextNode(Node.create({
          text: 'text'
        }), Node, 'text');
      });
      it("should return a valid text node, if cfg.tag = Text", function() {
        return expectValidTextNode(Node.create({
          tag: getText('text')
        }), Node, 'text');
      });
      it("should return a valid text node, if cfg.clazz = MyTextNode1", function() {
        return expectValidTextNode(Node.create({
          clazz: MyTextNode1
        }), MyTextNode1, 'text');
      });
      it("should return a valid text node, if cfg.clazz = MyTextNode2", function() {
        return expectValidTextNode(Node.create({
          clazz: MyTextNode2
        }), MyTextNode2, 'text');
      });
      it("should return a valid tag node, if cfg = HTMLELement", function() {
        return expectValidTagNode(Node.create(getTag('div')), Node, 'div');
      });
      it("should return a valid tag node, if cfg.tag = 'div'", function() {
        return expectValidTagNode(Node.create({
          tag: 'div'
        }), Node, 'div');
      });
      it("should return a valid tag node, if cfg.tag = HTMLELement", function() {
        return expectValidTagNode(Node.create({
          tag: getTag('div')
        }), Node, 'div');
      });
      it("should return a valid tag node, if cfg.tag = MyValidNode", function() {
        return expectValidTagNode(Node.create({
          tag: MyValidNode
        }), MyValidNode, 'div');
      });
      it("should return a valid tag node, if cfg.clazz = MyValidNode", function() {
        return expectValidTagNode(Node.create({
          clazz: MyValidNode
        }), MyValidNode, 'div');
      });
      it("should throw an error, if cfg = null", function() {
        return expect(function() {
          return Node.create();
        }).to["throw"]();
      });
      it("should throw an error, if neither tag nor text are set", function() {
        return expect(function() {
          return Node.create({});
        }).to["throw"]();
      });
      it("should throw an error, if cfg.tag = MyExtendedNode", function() {
        return expect(function() {
          return Node.create({
            tag: MyExtendedNode
          });
        }).to["throw"]();
      });
      it("should throw an error, if cfg.tag is invalid", function() {
        expect(function() {
          return Node.create({
            tag: 1
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            tag: true
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            tag: {}
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            tag: []
          });
        }).to["throw"]();
        return expect(function() {
          return Node.create({
            tag: function() {}
          });
        }).to["throw"]();
      });
      it("should throw an error, if cfg.text is invalid", function() {
        expect(function() {
          return Node.create({
            text: null
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            text: {}
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            text: []
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            text: function() {}
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            text: function() {
              return {};
            }
          });
        }).to["throw"]();
        return expect(function() {
          return Node.create({
            text: function() {
              return [];
            }
          });
        }).to["throw"]();
      });
      it("should throw an error, if cfg.clazz = MyExtendedNode, because neither tag nor text are set", function() {
        return expect(function() {
          return Node.create({
            clazz: MyExtendedNode
          });
        }).to["throw"]();
      });
      it("should not throw an error, if cfg.clazz = MyExtendedNode and tag = 'div'", function() {
        return expect(function() {
          return Node.create({
            tag: 'div',
            clazz: MyExtendedNode
          });
        }).to.not["throw"]();
      });
      it("should not throw an error, if cfg.clazz = MyExtendedNode and text = ''", function() {
        return expect(function() {
          return Node.create({
            text: '',
            clazz: MyExtendedNode
          });
        }).to.not["throw"]();
      });
      return it("should not throw an error, if cfg.text is valid", function() {
        expect(function() {
          return expectValidTextNode(Node.create({
            text: ''
          }), Node, '');
        }).to.not["throw"]();
        expect(function() {
          return expectValidTextNode(Node.create({
            text: 1
          }), Node, 1);
        }).to.not["throw"]();
        expect(function() {
          return expectValidTextNode(Node.create({
            text: true
          }), Node, true);
        }).to.not["throw"]();
        expect(function() {
          return expectValidTextNode(Node.create({
            text: function() {
              return '';
            }
          }), Node, '');
        }).to.not["throw"]();
        expect(function() {
          return expectValidTextNode(Node.create({
            text: function() {
              return 1;
            }
          }), Node, 1);
        }).to.not["throw"]();
        return expect(function() {
          return expectValidTextNode(Node.create({
            text: function() {
              return true;
            }
          }), Node, true);
        }).to.not["throw"]();
      });
    });
  });

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/src/js/node.js
4: function(module, exports, require) {
module.id = '../src/js/node.js';
// Generated by CoffeeScript 1.12.6

/*
    cfg as string || boolean || number
        node is a text node

    cfg as object
        tag can be
            string
                which is mapped to an component class
                the node name
            HTMLElement
            node class    -> render only
            node instance -> render only
            undefined/null if text is defined

    cfg as node instance # invalid in create

    cfg as HTMLElement -> in constructor only

    cfg as func -> has to return a valid node cfg


    cfg =
        tag:
        clazz:
        bind:
        inject:
        text:
        className:
        style:
        child:
        children:
        event handlers starting with 'on', camel case converts to kebab case




    update:

        if value == undefined -> no update
        if value == null      -> remove value
        else                  -> update
 */

(function() {
  var Node, addChild, addChildAt, before, behind, change, checkDom, classMap, clone, create, disposeNode, domList, extendsNode, getOrCall, init, initTagFromDom, initTagNode, initTextFromDom, initTextNode, isBool, isDom, isDomText, isFunc, isNot, isNumber, isObject, isSimple, isString, j, lastTime, len, map, normalizeEvent, normalizeName, remove, removeChild, removeChildAt, removeEvents, replace, replaceChild, unmap, update, updateAttr, updateBool, updateChildren, updateClass, updateEvent, updateKey, updateKeyNow, updateNow, updateProps, updateStyle, updateText, vendor, vendors,
    slice = [].slice;

  getOrCall = function(value) {
    if (isFunc(value)) {
      return value();
    } else {
      return value;
    }
  };

  isBool = function(value) {
    return typeof value === 'boolean';
  };

  isNumber = function(value) {
    return typeof value === 'number';
  };

  isString = function(value) {
    return typeof value === 'string' || value === value + '';
  };

  isObject = function(value) {
    return typeof value === 'object';
  };

  isFunc = function(value) {
    return typeof value === 'function';
  };

  isDom = function(value) {
    return value instanceof HTMLElement;
  };

  isDomText = function(value) {
    return value instanceof Text;
  };

  isNot = function(value) {
    return value === null || value === void 0;
  };

  isSimple = function(value) {
    var t;
    return (t = typeof value) === 'string' || t === 'number' || t === 'boolean';
  };

  extendsNode = function(value) {
    return isFunc(value) && ((value.prototype instanceof Node) || value === Node);
  };

  normalizeName = function(name) {
    return name.replace(/[A-Z]/g, function(name) {
      return '-' + name.toLowerCase();
    });
  };

  normalizeEvent = function(type) {
    type = type.slice(2);
    return type.charAt(0).toLowerCase() + normalizeName(type.slice(1));
  };

  Node = (function() {
    Node.DEFAULT_CLASS = Node;

    Node.CHECK_DOM = true;

    Node.TEXT_KIND = 0;

    Node.NODE_KIND = 1;

    function Node(cfg1) {
      this.cfg = cfg1;
      this.keep = this.keep === true || false;
      this.valid = this.valid === true || false;
      this.init();
    }

    Node.prototype.init = function() {
      return init(this);
    };

    Node.prototype.behind = function(dom) {
      return behind(this, dom);
    };

    Node.prototype.before = function(dom) {
      return before(this, dom);
    };

    Node.prototype.replace = function(dom) {
      return replace(this, dom);
    };

    Node.prototype.remove = function() {
      return remove(this);
    };

    Node.prototype.addChild = function(child) {
      return addChild(this, child);
    };

    Node.prototype.addChildAt = function(child, index) {
      return addChildAt(this, child, index);
    };

    Node.prototype.removeChild = function(child) {
      return removeChild(this, child);
    };

    Node.prototype.removeChildAt = function(index) {
      return removeChildAt(this, index);
    };

    Node.prototype.updateNow = function() {
      return updateNow(this);
    };

    Node.prototype.updateKeyNow = function(name, value) {
      return updateKeyNow(this, name, value);
    };

    Node.prototype.update = function() {
      return update(this);
    };

    Node.prototype.updateKey = function(name, value) {
      return updateKey(this, name, value);
    };

    Node.prototype.render = function() {
      return this.cfg;
    };

    Node.prototype.dispose = function() {};

    Node.prototype.clone = function() {
      return clone(this);
    };

    Node.prototype.onAdded = function() {};

    Node.prototype.onRemoved = function() {};

    Node.prototype.onMount = function() {};

    Node.prototype.onUnmount = function() {
      return this.keep;
    };

    Node.prototype.onUpdated = function() {};

    Node.prototype.onKeyUpdated = function() {};

    return Node;

  })();

  classMap = {};

  domList = [];

  map = function(tag, clazz, overwrite) {
    if (overwrite == null) {
      overwrite = false;
    }
    if (classMap[tag] && !overwrite) {
      throw new Error("A class is already mapped for tag " + tag + ".");
    }
    return classMap[tag] = clazz;
  };

  unmap = function(tag) {
    return delete classMap[tag];
  };

  create = function(cfg) {
    var clazz, tag;
    if (isNot(cfg)) {
      throw new Error("A node can't be created from empty cfg.");
    }
    if (!extendsNode(clazz = cfg.clazz)) {
      if (!extendsNode(clazz = cfg.tag)) {
        clazz = null;
        if (isDom(cfg)) {
          tag = cfg.nodeName.toLowerCase();
        }
        if (isString(tag = tag || cfg.tag)) {
          clazz = classMap[tag];
        }
      }
    }
    clazz = clazz || Node.DEFAULT_CLASS;
    return new clazz(cfg);
  };

  init = function(node) {
    var cfg, tag;
    if (isNot(cfg = node.render())) {
      throw new Error("A node can't be initialized with empty cfg.");
    }
    switch (true) {
      case isSimple(cfg):
        initTextNode(node, node.cfg = {
          text: cfg + ''
        });
        break;
      case isDom(cfg):
        initTagFromDom(node, null, cfg);
        break;
      case isDomText(cfg):
        initTextFromDom(node, null, cfg);
        break;
      default:
        tag = cfg.tag;
        switch (true) {
          case isNot(tag):
            initTextNode(node, cfg);
            break;
          case isString(tag):
            initTagNode(node, cfg);
            break;
          case isDom(tag):
            initTagFromDom(node, cfg, tag);
            break;
          case isDomText(tag):
            initTextFromDom(node, cfg, tag);
            break;
          default:
            if (extendsNode(tag)) {
              throw new Error("A tag must be a string or a HTMLElement, you specified a Node class.");
            }
            throw new Error("A tag must be a string or a HTMLElement.");
        }
    }
    return node;
  };

  initTextNode = function(node, cfg) {
    var text;
    text = cfg.text;
    if (isFunc(text)) {
      text = text();
    }
    if (!isSimple(text)) {
      throw new Error("The text for a text node must be a string, number or bool.");
    }
    node.text = text;
    node.tag = cfg.tag = null;
    node.view = document.createTextNode(text);
    return node;
  };

  initTagNode = function(node, cfg) {
    var tag;
    node.tag = tag = cfg.tag;
    node.view = document.createElement(tag);
    updateProps(node, cfg);
    return node;
  };

  initTextFromDom = function(node, cfg, dom) {
    var text;
    if (Node.CHECK_DOM) {
      checkDom(dom);
    }
    node.text = dom.nodeValue;
    node.tag = null;
    node.view = dom;
    if (cfg) {
      text = cfg.text;
      if (!isNot(text)) {
        if (isFunc(text)) {
          text = text();
        }
        if (!isSimple(text)) {
          throw new Error("The text for a text node must be a string, number or bool.");
        }
        node.text = dom.nodeValue = text;
      } else {
        cfg.text = node.text;
      }
    } else {
      node.cfg = {
        text: node.text
      };
    }
    return node;
  };

  initTagFromDom = function(node, cfg, dom) {
    if (Node.CHECK_DOM) {
      checkDom(dom);
    }
    node.tag = dom.nodeName.toLowerCase();
    node.view = dom;
    if (cfg && isString(cfg.tag) && cfg.tag !== node.tag) {
      throw new Error("A cfg and the dom element must have the same tag. Got " + cfg.tag + " and " + node.tag);
    }
    cfg = cfg || (node.cfg = {});
    cfg.tag = node.tag;
    return node;
  };

  checkDom = function(dom) {
    if (domList.indexOf(dom) > -1) {
      throw new Error('Dom element already controlled by another node.');
    }
    return domList.push(dom);
  };

  updateText = function(node, cfg) {
    var text;
    text = cfg.text;
    if (!isNot(text)) {
      if (isFunc(text)) {
        text = text();
      }
      if (!isSimple(text)) {
        throw new Error("The text for a text node must be a string, number or bool.");
      }
    } else {
      return cfg.text = node.text;
    }
  };

  updateProps = function(node, cfg) {
    var attr, attrs, name, propMap, value;
    console.log('updateProps: ', node, cfg);
    if (cfg instanceof Node) {
      cfg = cfg.render();
    }
    attrs = node.attrs || (node.attrs = {});
    propMap = Object.assign({}, attrs, node.events, cfg);
    if (propMap.hasOwnProperty('className')) {
      updateClass(node, cfg.className);
    }
    if (propMap.hasOwnProperty('style')) {
      updateStyle(node, cfg.style);
    }
    if (propMap.hasOwnProperty('children')) {
      updateChildren(node, cfg.children);
    }
    delete propMap.tag;
    delete propMap.clazz;
    delete propMap.__i__;
    delete propMap.keep;
    delete propMap.text;
    delete propMap.className;
    delete propMap.style;
    delete propMap.children;
    delete propMap.bindings;
    for (name in propMap) {
      attr = attrs[name];
      value = cfg[name];
      if (isBool(value) || (isNot(value) && isBool(attr))) {
        updateBool(node, value, name);
      } else {
        if (/^on/.test(name)) {
          updateEvent(node, value, name);
        } else {
          if (isFunc(value)) {
            value = value();
          }
          if (isBool(value)) {
            updateBool(node, value, name);
          } else {
            updateAttr(node, value, name);
          }
        }
      }
    }
    return node;
  };

  updateAttr = function(node, value, name) {
    var view;
    node.attrs[name] = node.view.getAttribute(name);
    if (node.attrs[name] === value) {
      return;
    }
    view = node.view;
    if (value !== null && value !== void 0) {
      view.setAttribute(name, value);
      view[name] = value;
      node.attrs[name] = value;
    } else {
      view.removeAttribute(name);
      delete view[name];
      delete node.attrs[name];
    }
    return null;
  };

  updateBool = function(node, value, name) {
    var view;
    node.attrs[name] = node.view[name];
    if (node.attrs[name] === value) {
      return;
    }
    view = node.view;
    if (isNot(value)) {
      view.removeAttribute(name);
      view[name] = false;
      delete node.attrs[name];
    } else if (value === false) {
      view.removeAttribute(name);
      view[name] = false;
      node.attrs[name] = false;
      console.log('set to false: ', view[name]);
    } else {
      view.setAttribute(name, '');
      view[name] = true;
      node.attrs[name] = true;
    }
    return null;
  };

  updateClass = function(node, value) {
    if (isFunc(value)) {
      value = value();
    }
    node.attrs.className = node.view.className;
    if (node.attrs.className === value) {
      return;
    }
    if (value) {
      node.view.className = value;
      node.attrs.className = value;
    } else {
      node.view.className = void 0;
      delete node.attrs.className;
    }
    return null;
  };

  updateStyle = function(node, style) {
    var attrs, changed, css, name, prop, propMap, sobj, value, view;
    view = node.view;
    attrs = node.attrs;
    sobj = attrs.style;
    if (!view) {
      return;
    }
    if (isFunc(style)) {
      style = style();
    }
    if (isNot(style)) {
      view.style.cssText = null;
      delete attrs.style;
    } else if (isString(style)) {
      view.style.cssText = style;
      attrs.style = style;
    } else {
      css = '';
      sobj = isObject(sobj) ? sobj : {};
      changed = false;
      propMap = Object.assign({}, style, sobj);
      for (name in propMap) {
        value = style[name];
        if (value !== sobj[name]) {
          changed = true;
        }
        sobj[name] = value;
        if (isNot(value)) {
          delete sobj[name];
        } else {
          prop = normalizeName(name);
          css += prop + ': ' + value + '; ';
        }
      }
      if (changed) {
        if (css.length) {
          css = css.slice(0, -1);
          view.style.cssText = css;
          attrs.style = sobj;
        } else {
          view.style.cssText = null;
          delete attrs.style;
        }
      }
    }
    return null;
  };

  updateEvent = function(node, callback, name) {
    var events, listener, type, view;
    events = node.events || (node.events = {});
    view = node.view;
    type = normalizeEvent(name);
    listener = events[name];
    if (isString(callback)) {
      callback = node[name];
    }
    if (listener !== callback) {
      if (listener) {
        view.removeEventListener(type, listener);
        delete events[name];
      }
      if (callback) {
        view.addEventListener(type, callback);
        events[name] = callback;
      }
    }
    return null;
  };

  removeEvents = function(node) {
    var events, listener, name, type, view;
    events = node.events;
    if (!events) {
      return null;
    }
    view = node.view;
    for (name in events) {
      listener = events[name];
      type = normalizeEvent(name);
      if (listener) {
        view.removeEventListener(type, listener);
      }
      delete events[name];
    }
    node.events = null;
    return null;
  };

  updateChildren = function(node, cfgs) {
    var cfg, child, children, i, j, l, ref;
    children = node.children || (node.children = []);
    if (isFunc(cfgs)) {
      cfgs = cfgs();
    }
    cfgs = isString(cfgs) ? [cfgs] : cfgs || [];
    l = children.length > cfgs.length ? children.length : cfgs.length;
    for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      child = children[i];
      cfg = cfgs[i];
      if (isFunc(cfg)) {
        cfg = cfg();
      }
      if (!child && !cfg) {
        throw new Error(("DOM ERROR: either child or cfg at index " + i + " must be defined. Got ") + child + ', ' + cfg);
      }
      if (!child) {
        addChild(node, cfg);
      } else if (!cfg) {
        removeChild(child);
      } else {
        change(child, cfg);
      }
    }
    children.length = cfgs.length;
    return null;
  };

  change = function(node, cfg) {
    var canUpdate, needsUpdate;
    needsUpdate = node.needsUpdate();
    canUpdate = node.canUpdate(cfg);
    if (node === cfg || node.constructor === cfg.tag) {
      if (needsUpdate && canUpdate) {
        updateProperties(node, node.render());
      }
      if (needsUpdate && !canUpdate) {
        replaceChild(node, node.render());
      }
    } else if (node.tag !== cfg.tag || cfg instanceof Node) {
      replaceChild(node, cfg);
    } else if (node.tag === void 0) {
      updateText(node, cfg);
    } else if (needsUpdate && canUpdate) {
      updateProperties(node, cfg);
    }
    return false;
  };

  addChild = function(node, cfg) {
    var child;
    if (cfg instanceof Node) {
      child = cfg;
    } else {
      child = create(cfg, null, cfg.__i__ || node.__i__);
    }
    cfg = child.render();
    if (!child.view) {
      child.view = createView(child, cfg);
    }
    node.children.push(child);
    node.view.appendChild(child.view);
    child.parent = node;
    child.depth = node.depth + 1;
    if (isSimple(cfg) || (!cfg.tag && isSimple(cfg.text))) {
      updateText(child, cfg);
    } else {
      updateProperties(child, cfg);
    }
    child.onMount();
    return null;
  };

  removeChild = function(child) {
    var node, view;
    node = child.parent;
    view = child.view;
    disposeNode(child);
    node.view.removeChild(view);
    return null;
  };

  replaceChild = function(child, cfg) {
    var children, i, node, view;
    node = child.parent;
    children = node.children;
    i = children.indexOf(child);
    view = child.view;
    disposeNode(child);
    if (cfg instanceof Node) {
      child = cfg;
      cfg = child.render();
    } else {
      child = create(cfg, null, cfg.__i__ || node.__i__);
    }
    cfg = child.render();
    if (!child.view) {
      child.view = createView(child, cfg);
    }
    children[i] = child;
    child.parent = node;
    child.depth = node.depth + 1;
    node.view.replaceChild(child.view, view);
    if (isSimple(cfg) || (!cfg.tag && isSimple(cfg.text))) {
      updateText(child, cfg);
    } else {
      updateProperties(child, cfg);
    }
    child.onMount();
    return null;
  };

  disposeNode = function(node) {
    var child, j, len, ref;
    if (node.onUnmount() !== true) {
      removeEvents(node);
      if (node.children && node.children.length) {
        ref = node.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          disposeNode(child);
        }
      }
      delete node.children;
      delete node.view;
      delete nodeMap[node.__id__];
    }
    node.parent = null;
    node.depth = void 0;
    return null;
  };

  behind = function(node, dom) {};

  before = function(node, dom) {};

  replace = function(node, dom) {};

  remove = function(node) {};

  addChild = function(node, child) {};

  addChildAt = function(node, child, index) {};

  removeChild = function(node, index) {};

  removeChildAt = function(node, index) {};

  updateNow = function(node) {};

  updateKeyNow = function(node, name, value) {};

  update = function(node) {};

  updateKey = function(node, name, value) {};

  disposeNode = function() {};

  clone = function() {};

  Node.create = create;

  Node.map = map;

  Node.unmap = unmap;

  Node.getOrCall = getOrCall;

  Node.isBool = isBool;

  Node.isNumber = isNumber;

  Node.isString = isString;

  Node.isObject = isObject;

  Node.isFunc = isFunc;

  Node.isDom = isDom;

  Node.isDomText = isDomText;

  Node.isNot = isNot;

  Node.isSimple = isSimple;

  Node.extendsNode = extendsNode;

  if (typeof window !== 'undefined') {
    lastTime = 0;
    vendors = ['webkit', 'moz'];
    for (j = 0, len = vendors.length; j < len; j++) {
      vendor = vendors[j];
      if (window.requestAnimationFrame) {
        break;
      }
      window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback) {
        var currTime, id, rAF, timeToCall;
        currTime = Date.now();
        timeToCall = Math.max(0, 16 - currTime + lastTime);
        rAF = function() {
          return callback(currTime + timeToCall);
        };
        id = window.setTimeout(rAF, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
        return null;
      };
    }
  }

  if (typeof Object.assign === 'undefined') {
    Object.assign = function() {
      var args, k, key, len1, src, target;
      target = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      for (k = 0, len1 = args.length; k < len1; k++) {
        src = args[k];
        for (key in src) {
          target[key] = src[key];
        }
      }
      return target;
    };
  }

  if (typeof module !== 'undefined') {
    module.exports = Node;
  }

  if (typeof window !== 'undefined') {
    window.Node = Node;
  } else {
    this.Node = Node;
  }

}).call(this);


}
});
//# sourceMappingURL=index.pack.js.map