(function(pack)
{
    var win = window,
        process = win.process || (win.process = {}),
        env     = process.env || (process.env = {}),
        cfg     = {
        index:      0,
        total:      1,
        startIndex: 0,
        type:       'register::0.48756901295027655_1501252643243',
        path:       '/Users/JOA/Projects/workspaces/my/two-trees/test/js/index.js',
        pack:       pack
    };
    env.NODE_ENV = env.NODE_ENV || 'development'
    var packer = // Generated by CoffeeScript 1.12.6
(function() {
  var Pack;

  Pack = (function() {
    function Pack() {}

    Pack.prototype.init = function(cfg) {
      this.cfg = cfg;
      this.mainIndex = this.cfg.startIndex;
      this.map = {};
      this.chunks = {};
      this.prepare();
      if (this.cfg.total === 1) {
        this.start();
      }
      return null;
    };

    Pack.prototype.prepare = function() {
      var pack;
      this.startTime = Date.now();
      this.registered = 1;
      pack = this.cfg.pack;
      this.getModule = (function(_this) {
        return function(index, chunk) {
          var m, r;
          if (chunk) {
            return _this.getChunk(index, chunk);
          }
          m = _this.map[index];
          if (m) {
            return m.exports;
          }
          m = _this.map[index] = {
            require: _this.getModule,
            exports: {}
          };
          r = pack[index];
          if (r) {
            r(m, m.exports, m.require);
            return m.exports;
          } else {
            console.log("Error requiring '" + index + "': module doesn't exist");
          }
          return null;
        };
      })(this);
      document.addEventListener(this.cfg.type, (function(_this) {
        return function(e) {
          return _this.handleEvent(e);
        };
      })(this));
      return null;
    };

    Pack.prototype.getChunk = function(index, chunk) {
      var chunks, loader, resolve, resolver, script;
      chunks = this.chunks[chunk];
      if (this.map[index]) {
        resolver = (function(_this) {
          return function(clazz) {
            return new Promise(function(r) {
              var m;
              m = _this.getModule(index);
              if (clazz) {
                r(m[clazz]);
              } else {
                r(m);
              }
              return null;
            });
          };
        })(this);
      } else {
        if (!chunks) {
          chunks = this.chunks[chunk] = [];
          script = document.createElement('script');
          script.src = chunk;
          document.body.appendChild(script);
        }
        loader = {};
        resolve = (function(_this) {
          return function() {
            var clazz, m;
            clazz = loader.clazz;
            m = _this.getModule(index);
            if (clazz) {
              return loader.r(m[clazz]);
            } else {
              return loader.r(m);
            }
          };
        })(this);
        loader.resolve = resolve;
        chunks.push(loader);
        resolver = function(clazz) {
          loader.clazz = clazz;
          return new Promise(function(r) {
            return loader.r = r;
          });
        };
      }
      return resolver;
    };

    Pack.prototype.start = function() {
      this.getModule(this.mainIndex);
      return null;
    };

    Pack.prototype.addPack = function(pack) {
      var key, value;
      for (key in pack) {
        value = pack[key];
        if (!this.cfg.pack[key]) {
          this.cfg.pack[key] = value;
        } else {
          console.log("Error adding module: module '" + key + "' already exists");
        }
      }
      return null;
    };

    Pack.prototype.handleEvent = function(e) {
      var chunk, chunks, detail, i, len, loader, pack;
      detail = e.detail;
      if (detail) {
        detail.registered = true;
        pack = detail.pack;
        if (pack) {
          null;
          this.addPack(pack);
        } else {
          console.log("Error adding pack: pack doesn't exists in details: ", detail);
        }
      } else {
        console.log("Error adding pack: detail doesn't exist in event: ", event);
      }
      chunk = detail.chunk;
      if (!chunk) {
        if (detail.index === 0) {
          this.mainIndex = detail.startIndex;
        }
        if (++this.registered === this.cfg.total) {
          this.start();
        }
      } else {
        chunks = this.chunks[chunk];
        if (chunks) {
          for (i = 0, len = chunks.length; i < len; i++) {
            loader = chunks[i];
            loader.resolve();
          }
        }
      }
      return null;
    };

    return Pack;

  })();

  return new Pack();

}).call(this);

    packer.init(cfg);
})({
// /Users/JOA/Projects/workspaces/my/two-trees/test/js/index.js
0: function(module, exports, require) {
module.id = 'js/index.js';
// Generated by CoffeeScript 1.12.6
(function() {
  require(1);

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/test/js/view-tree.js
1: function(module, exports, require) {
module.id = 'js/view-tree.js';
// Generated by CoffeeScript 1.12.6
(function() {
  var MyExtendedNode, MyTextNode1, MyTextNode2, MyValidNode, Node, ViewTree, expectAttr, expectBoolAttr, expectClass, expectExtends, expectTagNode, expectTextNode, getTag, getText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ViewTree = require(2);

  Node = ViewTree.Node;

  getTag = function(tag) {
    return document.createElement(tag);
  };

  getText = function(text) {
    return document.createTextNode(text);
  };

  MyValidNode = (function(superClass) {
    extend(MyValidNode, superClass);

    function MyValidNode() {
      return MyValidNode.__super__.constructor.apply(this, arguments);
    }

    MyValidNode.prototype.render = function() {
      return {
        tag: 'div'
      };
    };

    return MyValidNode;

  })(Node);

  MyTextNode1 = (function(superClass) {
    extend(MyTextNode1, superClass);

    function MyTextNode1() {
      return MyTextNode1.__super__.constructor.apply(this, arguments);
    }

    MyTextNode1.prototype.render = function() {
      return 'text';
    };

    return MyTextNode1;

  })(Node);

  MyTextNode2 = (function(superClass) {
    extend(MyTextNode2, superClass);

    function MyTextNode2() {
      return MyTextNode2.__super__.constructor.apply(this, arguments);
    }

    MyTextNode2.prototype.render = function() {
      return {
        text: 'text'
      };
    };

    return MyTextNode2;

  })(Node);

  MyExtendedNode = (function(superClass) {
    extend(MyExtendedNode, superClass);

    function MyExtendedNode() {
      return MyExtendedNode.__super__.constructor.apply(this, arguments);
    }

    return MyExtendedNode;

  })(Node);

  expectClass = function(node, clazz) {
    return expect(node.constructor).to.equal(clazz);
  };

  expectExtends = function(node, clazz) {
    return expect(node).to.be["instanceof"](clazz);
  };

  expectTextNode = function(node, clazz, text) {
    expectClass(node, clazz);
    expectExtends(node.view, Text);
    expect(node.kind).to.equal(Node.TEXT_KIND);
    expect(node.view.nodeValue).to.equal(text + '');
    return expect(node.text).to.equal(text);
  };

  expectTagNode = function(node, clazz, tag) {
    expectClass(node, clazz);
    expectExtends(node.view, HTMLElement);
    expect(node.kind).to.equal(Node.TAG_KIND);
    expect(node.view.nodeName.toLowerCase()).to.equal(tag);
    return expect(node.tag).to.equal(tag);
  };

  expectAttr = function(node, name, value) {
    expectExtends(node.view, HTMLElement);
    expect(node.kind).to.equal(Node.TAG_KIND);
    expect(node.attrs[name]).to.equal(value = Node.getOrCall(value));
    return expect(node.view.getAttribute(name)).to.equal(value + '');
  };

  expectBoolAttr = function(node, name, value) {
    expectExtends(node.view, HTMLElement);
    expect(node.attrs[name]).to.equal(value = Node.getOrCall(value));
    if (value === true) {
      expect(node.view.getAttribute(name)).to.equal('');
      return expect(node.view[name]).to.equal(value);
    } else {
      expect(node.view.getAttribute(name)).to.equal(null);
      return expect(node.view[name]).to.equal(value);
    }
  };

  describe('Node', function() {
    return describe('.create', function() {
      it("should return a valid text node, if cfg = 'text'", function() {
        return expectTextNode(Node.create('text'), Node, 'text');
      });
      it("should return a valid text node, if cfg = Text", function() {
        return expectTextNode(Node.create(getText('text')), Node, 'text');
      });
      it("should return a valid text node, if cfg.text = 'text'", function() {
        return expectTextNode(Node.create({
          text: 'text'
        }), Node, 'text');
      });
      it("should return a valid text node, if cfg.tag = Text", function() {
        return expectTextNode(Node.create({
          tag: getText('text')
        }), Node, 'text');
      });
      it("should return a valid text node, if cfg.clazz = MyTextNode1", function() {
        return expectTextNode(Node.create({
          clazz: MyTextNode1
        }), MyTextNode1, 'text');
      });
      it("should return a valid text node, if cfg.clazz = MyTextNode2", function() {
        return expectTextNode(Node.create({
          clazz: MyTextNode2
        }), MyTextNode2, 'text');
      });
      it("should return a valid tag node, if cfg = HTMLELement", function() {
        return expectTagNode(Node.create(getTag('div')), Node, 'div');
      });
      it("should return a valid tag node, if cfg.tag = 'div'", function() {
        return expectTagNode(Node.create({
          tag: 'div'
        }), Node, 'div');
      });
      it("should return a valid tag node, if cfg.tag = HTMLELement", function() {
        return expectTagNode(Node.create({
          tag: getTag('div')
        }), Node, 'div');
      });
      it("should return a valid tag node, if cfg.tag = MyValidNode", function() {
        return expectTagNode(Node.create({
          tag: MyValidNode
        }), MyValidNode, 'div');
      });
      it("should return a valid tag node, if cfg.clazz = MyValidNode", function() {
        return expectTagNode(Node.create({
          clazz: MyValidNode
        }), MyValidNode, 'div');
      });
      it("should throw an error, if cfg = null", function() {
        return expect(function() {
          return Node.create();
        }).to["throw"]();
      });
      it("should throw an error, if neither tag nor text are set", function() {
        return expect(function() {
          return Node.create();
        }).to["throw"]();
      });
      it("should throw an error, if cfg.tag = MyExtendedNode", function() {
        return expect(function() {
          return Node.create({
            tag: MyExtendedNode
          });
        }).to["throw"]();
      });
      it("should throw an error, if cfg.tag is invalid", function() {
        expect(function() {
          return Node.create({
            tag: 1
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            tag: true
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            tag: {}
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            tag: []
          });
        }).to["throw"]();
        return expect(function() {
          return Node.create({
            tag: function() {}
          });
        }).to["throw"]();
      });
      it("should throw an error, if cfg.text is invalid", function() {
        expect(function() {
          return Node.create({
            text: null
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            text: {}
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            text: []
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            text: function() {}
          });
        }).to["throw"]();
        expect(function() {
          return Node.create({
            text: function() {
              return {};
            }
          });
        }).to["throw"]();
        return expect(function() {
          return Node.create({
            text: function() {
              return [];
            }
          });
        }).to["throw"]();
      });
      it("should throw an error, if cfg.clazz = MyExtendedNode, because neither tag nor text are set", function() {
        return expect(function() {
          return Node.create({
            clazz: MyExtendedNode
          });
        }).to["throw"]();
      });
      it("should not throw an error, if cfg.clazz = MyExtendedNode and tag = 'div'", function() {
        Node.create({
          tag: 'div',
          clazz: MyExtendedNode
        });
        return expect(function() {
          return Node.create({
            tag: 'div',
            clazz: MyExtendedNode
          });
        }).to.not["throw"]();
      });
      it("should not throw an error, if cfg.clazz = MyExtendedNode and text = ''", function() {
        return expect(function() {
          return Node.create({
            text: '',
            clazz: MyExtendedNode
          });
        }).to.not["throw"]();
      });
      return it("should not throw an error, if cfg.text is valid", function() {
        expect(function() {
          return expectTextNode(Node.create({
            text: ''
          }), Node, '');
        }).to.not["throw"]();
        expect(function() {
          return expectTextNode(Node.create({
            text: 1
          }), Node, 1);
        }).to.not["throw"]();
        expect(function() {
          return expectTextNode(Node.create({
            text: true
          }), Node, true);
        }).to.not["throw"]();
        expect(function() {
          return expectTextNode(Node.create({
            text: function() {
              return '';
            }
          }), Node, '');
        }).to.not["throw"]();
        expect(function() {
          return expectTextNode(Node.create({
            text: function() {
              return 1;
            }
          }), Node, 1);
        }).to.not["throw"]();
        return expect(function() {
          return expectTextNode(Node.create({
            text: function() {
              return true;
            }
          }), Node, true);
        }).to.not["throw"]();
      });
    });
  });

  describe('new Node', function() {
    describe('init', function() {
      it("should return a valid text node, if cfg = 'text'", function() {
        return expectTextNode(new Node('text'), Node, 'text');
      });
      it("should return a valid text node, if cfg = Text", function() {
        return expectTextNode(new Node(getText('text')), Node, 'text');
      });
      it("should return a valid text node, if cfg.text = 'text'", function() {
        return expectTextNode(new Node({
          text: 'text'
        }), Node, 'text');
      });
      it("should return a valid text node, if cfg.tag = Text", function() {
        return expectTextNode(new Node({
          tag: getText('text')
        }), Node, 'text');
      });
      it("should return a valid tag node, if cfg = HTMLELement", function() {
        return expectTagNode(new Node(getTag('div')), Node, 'div');
      });
      it("should return a valid tag node, if cfg.tag = 'div'", function() {
        return expectTagNode(new Node({
          tag: 'div'
        }), Node, 'div');
      });
      return it("should return a valid tag node, if cfg.tag = HTMLELement", function() {
        return expectTagNode(new Node({
          tag: getTag('div')
        }), Node, 'div');
      });
    });
    describe('init error', function() {
      it("should throw an error, if cfg = null", function() {
        return expect(function() {
          return new Node();
        }).to["throw"]();
      });
      it("should throw an error, if neither tag nor text are set", function() {
        return expect(function() {
          return new Node({});
        }).to["throw"]();
      });
      it("should throw an error, if cfg.tag is invalid", function() {
        expect(function() {
          return new Node({
            tag: 1
          });
        }).to["throw"]();
        expect(function() {
          return new Node({
            tag: true
          });
        }).to["throw"]();
        expect(function() {
          return new Node({
            tag: {}
          });
        }).to["throw"]();
        expect(function() {
          return new Node({
            tag: []
          });
        }).to["throw"]();
        expect(function() {
          return new Node({
            tag: function() {}
          });
        }).to["throw"]();
        return expect(function() {
          return new Node({
            tag: Node
          });
        }).to["throw"]();
      });
      it("should throw an error, if cfg.text is invalid", function() {
        expect(function() {
          return new Node({
            text: null
          });
        }).to["throw"]();
        expect(function() {
          return new Node({
            text: {}
          });
        }).to["throw"]();
        expect(function() {
          return new Node({
            text: []
          });
        }).to["throw"]();
        expect(function() {
          return new Node({
            text: function() {}
          });
        }).to["throw"]();
        expect(function() {
          return new Node({
            text: function() {
              return {};
            }
          });
        }).to["throw"]();
        return expect(function() {
          return new Node({
            text: function() {
              return [];
            }
          });
        }).to["throw"]();
      });
      return it("should not throw an error, if cfg.text is valid", function() {
        expect(function() {
          return expectTextNode(new Node({
            text: ''
          }), Node, '');
        }).to.not["throw"]();
        expect(function() {
          return expectTextNode(new Node({
            text: 1
          }), Node, 1);
        }).to.not["throw"]();
        expect(function() {
          return expectTextNode(new Node({
            text: true
          }), Node, true);
        }).to.not["throw"]();
        expect(function() {
          return expectTextNode(new Node({
            text: function() {
              return '';
            }
          }), Node, '');
        }).to.not["throw"]();
        expect(function() {
          return expectTextNode(new Node({
            text: function() {
              return 1;
            }
          }), Node, 1);
        }).to.not["throw"]();
        return expect(function() {
          return expectTextNode(new Node({
            text: function() {
              return true;
            }
          }), Node, true);
        }).to.not["throw"]();
      });
    });
    describe('with attr', function() {
      return it("should create a attr title = 'my title'", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          title: 'my title'
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectAttr(node, 'title', 'my title');
      });
    });
    describe('with bool', function() {
      it("should create a bool attr disabled = true", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          disabled: true
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectBoolAttr(node, 'disabled', true);
      });
      it("should create a bool attr disabled = false", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          disabled: false
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectBoolAttr(node, 'disabled', false);
      });
      return it("should remove a bool attr disabled = undefined", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          disabled: void 0
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectBoolAttr(node, 'disabled', void 0);
      });
    });
    describe('with tag children', function() {
      it("should add a child tag node if children = [tag: 'div']", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: [
            {
              tag: 'div'
            }
          ]
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTagNode(node.children[0], Node, 'div');
      });
      it("should add a child tag node with class MyExtendedNode if children = [{tag: 'div', clazz:MyExtendedNode}]", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: [
            {
              tag: 'div',
              clazz: MyExtendedNode
            }
          ]
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTagNode(node.children[0], MyExtendedNode, 'div');
      });
      it("should add a child tag node if children = [HTMLElement]", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: [getTag('div')]
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTagNode(node.children[0], Node, 'div');
      });
      it("should add a child tag node if children = [tag:HTMLElement]", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: [
            {
              tag: getTag('div')
            }
          ]
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTagNode(node.children[0], Node, 'div');
      });
      return it("should add a child tag node with class MyExtendedNode if children = [{tag: HTMLElement, clazz:MyExtendedNode}]", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: [
            {
              tag: getTag('div'),
              clazz: MyExtendedNode
            }
          ]
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTagNode(node.children[0], MyExtendedNode, 'div');
      });
    });
    describe('with tag child', function() {
      it("should add a child tag node if child = tag: 'div'", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          child: {
            tag: 'div'
          }
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTagNode(node.children[0], Node, 'div');
      });
      it("should add a child tag node if child = HTMLElement", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          child: getTag('div')
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTagNode(node.children[0], Node, 'div');
      });
      return it("should add a child tag node if child = tag: HTMLElement", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          child: {
            tag: getTag('div')
          }
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTagNode(node.children[0], Node, 'div');
      });
    });
    describe('with text children', function() {
      it("should add a child text node if children = 'my text'", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: 'my text'
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
      it("should add a child text node if children = ['my text']", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: ['my text']
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
      it("should add a child text node if children = [Text]", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: [getText('my text')]
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
      it("should add a child text node if children = [text:'my text']", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: [
            {
              text: 'my text'
            }
          ]
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
      it("should add a child text node with class MyExtendedNode if children = [{text:'my text', clazz:MyExtendedNode}]", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: [
            {
              text: 'my text',
              clazz: MyExtendedNode
            }
          ]
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], MyExtendedNode, 'my text');
      });
      return it("should add a child text node with class MyExtendedNode if children = [{tag:Text, clazz:MyExtendedNode}]", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          children: [
            {
              tag: getText('my text'),
              clazz: MyExtendedNode
            }
          ]
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], MyExtendedNode, 'my text');
      });
    });
    describe('with text', function() {
      it("should add a child text node if text = 'my text'", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          text: 'my text'
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
      return it("should add a child text node if text = Text", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          text: getText('my text')
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
    });
    return describe('with text child', function() {
      it("should add a child text node if child = 'my text'", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          child: 'my text'
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
      it("should add a child text node if child = text:'my text'", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          child: {
            text: 'my text'
          }
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
      it("should add a child text node if child = Text", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          child: getText('my text')
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
      return it("should add a child text node if child = tag: Text", function() {
        var cfg, node;
        cfg = {
          tag: 'div',
          child: {
            tag: getText('my text')
          }
        };
        expectTagNode(node = new Node(cfg), Node, 'div');
        return expectTextNode(node.children[0], Node, 'my text');
      });
    });
  });

  describe('node instance', function() {
    describe('appendTo', function() {
      it('should append the nodes view to the dom', function() {
        var node, parent;
        parent = getTag('div');
        node = new Node({
          tag: 'div'
        });
        node.appendTo(parent);
        expect(parent.childNodes[0]).to.equal(node.view);
        return expect(parent.childNodes.length).to.equal(1);
      });
      it('should throw an error if the dom is controlled by a node', function() {
        var node, parent;
        parent = new Node({
          tag: 'div'
        });
        node = new Node({
          tag: 'div'
        });
        return expect(function() {
          return node.appendTo(parent.view);
        }).to["throw"]();
      });
      return it('should not throw an error if Node.CHECK_DOM = false', function() {
        var node, parent;
        Node.CHECK_DOM = false;
        parent = new Node({
          tag: 'div'
        });
        node = new Node({
          tag: 'div'
        });
        expect(function() {
          return node.appendTo(parent.view);
        }).to.not["throw"]();
        return Node.CHECK_DOM = true;
      });
    });
    describe('behind', function() {
      it('should append the nodes view behind the dom', function() {
        var node, parent, prev;
        parent = getTag('div');
        node = new Node({
          tag: 'div'
        });
        parent.appendChild(getTag('div'));
        parent.appendChild(prev = getTag('div'));
        parent.appendChild(getTag('div'));
        node.behind(prev);
        expect(parent.childNodes[2]).to.equal(node.view);
        return expect(parent.childNodes.length).to.equal(4);
      });
      it('should append the nodes view behind the dom if the dom is the last child', function() {
        var node, parent, prev;
        parent = getTag('div');
        node = new Node({
          tag: 'div'
        });
        parent.appendChild(getTag('div'));
        parent.appendChild(getTag('div'));
        parent.appendChild(prev = getTag('div'));
        node.behind(prev);
        expect(parent.childNodes[3]).to.equal(node.view);
        return expect(parent.childNodes.length).to.equal(4);
      });
      it('should throw an error if the doms parent is controlled by a node', function() {
        var node, parent, prev;
        parent = new Node({
          tag: 'div'
        });
        node = new Node({
          tag: 'div'
        });
        parent.view.appendChild(prev = getTag('div'));
        return expect(function() {
          return node.behind(prev);
        }).to["throw"]();
      });
      return it('should not throw an error if Node.CHECK_DOM = false', function() {
        var node, parent, prev;
        Node.CHECK_DOM = false;
        parent = new Node({
          tag: 'div'
        });
        node = new Node({
          tag: 'div'
        });
        parent.view.appendChild(prev = getTag('div'));
        expect(function() {
          return node.behind(prev);
        }).to.not["throw"]();
        return Node.CHECK_DOM = true;
      });
    });
    describe('before', function() {
      it('should prepand the nodes view before the dom', function() {
        var next, node, parent;
        parent = getTag('div');
        node = new Node({
          tag: 'div'
        });
        parent.appendChild(getTag('div'));
        parent.appendChild(next = getTag('div'));
        node.before(next);
        expect(parent.childNodes[1]).to.equal(node.view);
        return expect(parent.childNodes.length).to.equal(3);
      });
      it('should throw an error if the doms parent is controlled by a node', function() {
        var next, node, parent;
        parent = new Node({
          tag: 'div'
        });
        node = new Node({
          tag: 'div'
        });
        parent.view.appendChild(next = getTag('div'));
        return expect(function() {
          return node.before(next);
        }).to["throw"]();
      });
      return it('should not throw an error if Node.CHECK_DOM = false', function() {
        var next, node, parent;
        Node.CHECK_DOM = false;
        parent = new Node({
          tag: 'div'
        });
        node = new Node({
          tag: 'div'
        });
        parent.view.appendChild(next = getTag('div'));
        expect(function() {
          return node.before(next);
        }).to.not["throw"]();
        return Node.CHECK_DOM = true;
      });
    });
    return describe('replace', function() {
      it('should replace the dom with the nodes view', function() {
        var node, old, parent;
        parent = getTag('div');
        node = new Node({
          tag: 'div'
        });
        parent.appendChild(old = getTag('div'));
        node.replace(old);
        expect(parent.childNodes[0]).to.equal(node.view);
        return expect(parent.childNodes.length).to.equal(1);
      });
      it('should throw an error if the doms parent is controlled by a node', function() {
        var node, old, parent;
        parent = new Node({
          tag: 'div'
        });
        node = new Node({
          tag: 'div'
        });
        parent.view.appendChild(old = getTag('div'));
        return expect(function() {
          return node.replace(old);
        }).to["throw"]();
      });
      it('should not throw an error for the doms parent if Node.CHECK_DOM = false', function() {
        var node, old, parent;
        Node.CHECK_DOM = false;
        parent = new Node({
          tag: 'div'
        });
        node = new Node({
          tag: 'div'
        });
        parent.view.appendChild(old = getTag('div'));
        expect(function() {
          return node.replace(old);
        }).to.not["throw"]();
        return Node.CHECK_DOM = true;
      });
      it('should throw an error if the dom is controlled by a node', function() {
        var node, old, parent;
        parent = getTag('div');
        node = new Node({
          tag: 'div'
        });
        parent.appendChild(old = (new Node({
          tag: 'div'
        })).view);
        return expect(function() {
          return node.replace(old);
        }).to["throw"]();
      });
      return it('should not throw an error for the dom if Node.CHECK_DOM = false', function() {
        var node, old, parent;
        Node.CHECK_DOM = false;
        parent = getTag('div');
        node = new Node({
          tag: 'div'
        });
        parent.appendChild(old = (new Node({
          tag: 'div'
        })).view);
        expect(function() {
          return node.replace(old);
        }).to.not["throw"]();
        return Node.CHECK_DOM = true;
      });
    });
  });

}).call(this);


},
// /Users/JOA/Projects/workspaces/my/two-trees/src/js/view-tree.js
2: function(module, exports, require) {
module.id = '../src/js/view-tree.js';
// Generated by CoffeeScript 1.12.6
(function() {
  var Node, ViewTree, __id__, addChild, append, before, behind, change, checkDom, classMap, cleanMap, create, createTagFromDom, createTagView, createTextFromDom, createTextView, createView, dirty, dirtyMap, disposeNode, domList, extendsNode, getOrCall, injectNode, isBool, isDom, isDomText, isFunc, isNot, isNumber, isObject, isSimple, isString, j, lastTime, len, map, nodeMap, normalizeEvent, normalizeName, rafTimeout, remove, removeChild, removeEvents, render, replace, replaceChild, unmap, update, updateAttr, updateBool, updateChildren, updateClass, updateEvent, updateNow, updateProperties, updateStyle, updateText, vendor, vendors,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  __id__ = 0;

  getOrCall = function(value) {
    if (isFunc(value)) {
      return value();
    } else {
      return value;
    }
  };

  isBool = function(value) {
    return typeof value === 'boolean';
  };

  isNumber = function(value) {
    return typeof value === 'number';
  };

  isString = function(value) {
    return typeof value === 'string' || value === value + '';
  };

  isObject = function(value) {
    return typeof value === 'object';
  };

  isFunc = function(value) {
    return typeof value === 'function';
  };

  isDom = function(value) {
    return value instanceof HTMLElement;
  };

  isDomText = function(value) {
    return value instanceof Text;
  };

  isNot = function(value) {
    return value === null || value === void 0;
  };

  isSimple = function(value) {
    var t;
    return (t = typeof value) === 'string' || t === 'number' || t === 'boolean';
  };

  extendsNode = function(value) {
    return isFunc(value) && ((value.prototype instanceof Node) || value === Node);
  };

  normalizeName = function(name) {
    return name.replace(/[A-Z]/g, function(name) {
      return '-' + name.toLowerCase();
    });
  };

  normalizeEvent = function(type) {
    type = type.slice(2);
    return type.charAt(0).toLowerCase() + normalizeName(type.slice(1));
  };


  /*
      cfg as string || boolean || number
          node is a text node
  
      cfg as object
          tag can be
              string
                  which is mapped to an component class
                  the node name
              node class
              node instance
  
      cfg as node instance # invalid in create
  
      cfg as func
  
  
      cfg =
          tag:
          text:
          style:
          bind
          clazz:
          child:
          children:
          event handlers starting with 'on', camel case converts to kebab case
  
  
      update:
  
          if value == undefined -> no update
          if value == null      -> remove value
          else                  -> update
   */

  Node = (function() {
    Node.DEBUG = true;

    Node.CHECK_DOM = true;

    function Node(opts) {
      this.update = bind(this.update, this);
      this.register(opts);
      this.updateCfg(opts);
      this.updateNow();
    }

    Node.prototype.register = function(cfg1) {
      this.cfg = cfg1;
      this.parent = null;
      this.depth = 0;
      this.keep = false;
      if (!this.__id__) {
        this.__id__ = ++__id__;
        nodeMap[this.__id__] = this;
      }
      this.__id__;
      return injectNode(this, this.cfg);
    };

    Node.prototype.updateNow = function(cfg) {
      cfg = cfg || this.render();
      if (isNot(this.view)) {
        createView(this, cfg);
      }
      if (isSimple(cfg) || (!cfg.tag && (isSimple(cfg.text) || isFunc(cfg.text)))) {
        updateText(this, cfg);
      } else {
        updateProperties(this, cfg);
      }
      return this;
    };

    Node.prototype.appendTo = function(dom) {
      if (!this.view) {
        this.updateNow();
      }
      return append(this, dom);
    };

    Node.prototype.behind = function(dom) {
      if (!this.view) {
        this.updateNow();
      }
      return behind(this, dom);
    };

    Node.prototype.before = function(dom) {
      if (!this.view) {
        this.updateNow();
      }
      return before(this, dom);
    };

    Node.prototype.replace = function(dom) {
      if (!this.view) {
        this.updateNow();
      }
      return replace(this, dom);
    };

    Node.prototype.remove = function(dom) {
      if (!this.view) {
        this.updateNow();
      }
      return replace(this, dom);
    };

    Node.prototype.dispose = function() {
      return null;
    };

    Node.prototype.onMount = function() {
      return null;
    };

    Node.prototype.onUnmount = function() {
      return this.keep;
    };

    Node.prototype.updateCfg = function(cfg) {
      return (this.cfg = cfg) || true;
    };

    Node.prototype.update = function() {
      return update(this);
    };

    Node.prototype.render = function() {
      return this.cfg;
    };

    Node.prototype.onAdded = function() {};

    Node.prototype.onRemoved = function() {};

    Node.prototype.addChild = function(child) {};

    Node.prototype.addChildAt = function(child, index) {};

    Node.prototype.removeChild = function(child) {};

    Node.prototype.removeChildAt = function(index) {};

    return Node;

  })();

  classMap = {};

  nodeMap = {};

  dirtyMap = {};

  cleanMap = {};

  domList = [];

  dirty = false;

  rafTimeout = null;

  map = function(tag, clazz, overwrite) {
    if (overwrite == null) {
      overwrite = false;
    }
    if (isNot(classMap[tag]) || overwrite) {
      classMap[tag] = clazz;
    }
    return null;
  };

  unmap = function(tag) {
    delete classMap[tag];
    return null;
  };

  create = function(cfg, root) {
    var clazz, node, tag;
    if (root == null) {
      root = null;
    }
    if (isNot(cfg)) {
      throw new Error("A node can't be created from empty cfg.");
    }
    if (!extendsNode(clazz = cfg.clazz)) {
      if (!extendsNode(clazz = cfg.tag)) {
        clazz = null;
        if (isDom(cfg)) {
          tag = cfg.nodeName.toLowerCase();
        }
        if (isString(tag = tag || cfg.tag)) {
          clazz = classMap[tag];
        }
      }
    }
    clazz = clazz || ViewTree.DEFAULT_CLASS;
    node = new clazz(cfg);
    if (root !== null) {
      render(node, root);
    }
    return node;
  };

  injectNode = function(node, cfg) {
    var inject, key, value;
    if (isNot(node.__i__) && cfg && cfg.__i__) {
      inject = node.__i__ = cfg.__i__;
      for (key in inject) {
        value = inject[key];
        node[key] = value;
      }
    }
    return node;
  };

  createView = function(node, cfg) {
    var tag;
    if (node.view) {
      throw new Error("View already exists");
    }
    if (isNot(cfg = node.render())) {
      throw new Error("A view for an empty cfg can't be created.");
    }
    switch (true) {
      case isSimple(cfg):
        createTextView(node, node.cfg = {
          text: cfg + ''
        });
        break;
      case isDom(cfg):
        createTagFromDom(node, null, cfg);
        break;
      case isDomText(cfg):
        createTextFromDom(node, null, cfg);
        break;
      default:
        tag = cfg.tag;
        switch (true) {
          case isNot(tag):
            createTextView(node, cfg);
            break;
          case isString(tag):
            createTagView(node, cfg);
            break;
          case isDom(tag):
            createTagFromDom(node, cfg, tag);
            break;
          case isDomText(tag):
            createTextFromDom(node, cfg, tag);
            break;
          default:
            if (extendsNode(tag)) {
              throw new Error("A tag must be a string or a HTMLElement, you specified a Node class.");
            }
            throw new Error("A tag must be a string or a HTMLElement.");
        }
    }
    if (Node.CHECK_DOM) {
      domList.push(node.view);
    }
    return node;
  };

  createTextView = function(node, cfg) {
    var text;
    text = cfg.text;
    if (isFunc(text)) {
      text = text();
    }
    if (!isSimple(text)) {
      throw new Error("The text for a text node must be a string, number or bool.");
    }
    node.text = text;
    node.tag = cfg.tag = null;
    node.kind = Node.TEXT_KIND;
    return node.view = document.createTextNode(text);
  };

  createTextFromDom = function(node, cfg, dom) {
    var text;
    if (Node.CHECK_DOM) {
      checkDom(dom);
    }
    node.text = dom.nodeValue;
    node.tag = null;
    node.kind = Node.TEXT_KIND;
    node.view = dom;
    if (cfg) {
      text = cfg.text;
      if (isNot(text)) {
        cfg.text = node.text;
      } else {
        if (isFunc(text)) {
          text = text();
        }
        if (!isSimple(text)) {
          throw new Error("The text for a text node must be a string, number or bool.");
        }
        node.text = dom.nodeValue = text;
      }
    } else {
      cfg = node.cfg = {
        text: node.text
      };
    }
    cfg.tag = null;
    return node;
  };

  createTagView = function(node, cfg) {
    var tag;
    node.tag = tag = cfg.tag;
    node.kind = Node.TAG_KIND;
    node.view = document.createElement(tag);
    return node;
  };

  createTagFromDom = function(node, cfg, dom) {
    if (Node.CHECK_DOM) {
      checkDom(dom);
    }
    node.tag = dom.nodeName.toLowerCase();
    node.kind = Node.TAG_KIND;
    node.view = dom;
    cfg = cfg || (node.cfg = {});
    cfg.tag = node.tag;
    return node;
  };

  render = function(node, root) {
    var cfg;
    cfg = node.render();
    if (!node.view) {
      createView(node, cfg);
    }
    root.appendChild(node.view);
    node.updateNow();
    node.onMount();
    return null;
  };

  remove = function(nodeOrRoot) {};

  update = function(node) {
    var id;
    id = node != null ? node.__id__ : void 0;
    if (!id) {
      throw new Error("Can't update node. Node doesn't exist.");
    }
    if (!dirty) {
      window.cancelAnimationFrame(rafTimeout);
      rafTimeout = window.requestAnimationFrame(updateNow);
    }
    dirtyMap[id] = true;
    dirty = true;
    return null;
  };

  updateNow = function() {
    var cfg, id, j, len, n, node, nodes;
    window.cancelAnimationFrame(rafTimeout);
    dirty = false;
    cleanMap = {};
    nodes = [];
    for (id in dirtyMap) {
      if (n = nodeMap[id]) {
        nodes.push(n);
      }
    }
    nodes.sort(function(a, b) {
      return a.depth - b.depth;
    });
    for (j = 0, len = nodes.length; j < len; j++) {
      node = nodes[j];
      if (!node.view || !nodeMap[node.__id__] || cleanMap[node.__id__]) {
        continue;
      }
      cfg = node.render();
      if (isNot(node.tag) && isNot(cfg.tag)) {
        updateText(node, cfg);
      } else if (!(node.tag === cfg.tag || node.constructor === cfg.tag)) {
        replaceChild(node, cfg);
      } else {
        updateProperties(node, cfg);
      }
    }
    dirtyMap = {};
    return null;
  };

  updateText = function(node, cfg) {
    var text;
    cleanMap[node.__id__] = true;
    text = isFunc(cfg.text) ? cfg.text() : isString(cfg) ? cfg : cfg.text;
    if (node.text !== text) {
      node.cfg = cfg;
      node.text = text;
      node.view.nodeValue = text;
    }
    return null;
  };

  updateProperties = function(node, cfg) {
    var attr, attrs, child, name, propMap, text, value;
    cleanMap[node.__id__] = true;
    if (cfg instanceof Node) {
      cfg = cfg.render();
    }
    attrs = node.attrs || (node.attrs = {});
    propMap = Object.assign({}, attrs, node.events, cfg);
    if (propMap.hasOwnProperty('className')) {
      updateClass(node, cfg.className);
    }
    if (propMap.hasOwnProperty('style')) {
      updateStyle(node, cfg.style);
    }
    if (propMap.hasOwnProperty('text')) {
      if (isFunc(text = cfg.text)) {
        text = text();
      }
      if (isSimple(text)) {
        updateChildren(node, [text]);
      } else if (isDomText(text)) {
        updateChildren(node, [text]);
      }
      if (Node.DEBUG) {
        if (cfg.hasOwnProperty('child')) {
          console.warn('child specified while text exists: ', cfg);
        }
        if (cfg.hasOwnProperty('children')) {
          console.warn('children specified while text exists', cfg);
        }
      }
    } else if (propMap.hasOwnProperty('child')) {
      if (isFunc(child = cfg.child)) {
        child = child();
      }
      updateChildren(node, [child]);
      if (Node.DEBUG) {
        if (cfg.hasOwnProperty('children')) {
          console.warn('children specified while text exists', cfg);
        }
      }
    } else if (propMap.hasOwnProperty('children')) {
      updateChildren(node, cfg.children);
    }
    delete propMap.tag;
    delete propMap.clazz;
    delete propMap.__i__;
    delete propMap.keep;
    delete propMap.text;
    delete propMap.child;
    delete propMap.className;
    delete propMap.style;
    delete propMap.children;
    delete propMap.bindings;
    for (name in propMap) {
      attr = attrs[name];
      value = cfg[name];
      if (isBool(value) || (isNot(value) && isBool(attr))) {
        updateBool(node, value, name);
      } else {
        if (/^on/.test(name)) {
          updateEvent(node, value, name);
        } else {
          if (isFunc(value)) {
            value = value();
          }
          if (isBool(value)) {
            updateBool(node, value, name);
          } else {
            updateAttr(node, value, name);
          }
        }
      }
    }
    return null;
  };

  updateAttr = function(node, value, name) {
    var view;
    node.attrs[name] = node.view.getAttribute(name);
    if (node.attrs[name] === value) {
      return;
    }
    view = node.view;
    if (value !== null && value !== void 0) {
      view.setAttribute(name, value);
      view[name] = value;
      node.attrs[name] = value;
    } else {
      view.removeAttribute(name);
      delete view[name];
      delete node.attrs[name];
    }
    return null;
  };

  updateBool = function(node, value, name) {
    var view;
    node.attrs[name] = node.view[name];
    if (node.attrs[name] === value) {
      return;
    }
    view = node.view;
    if (isNot(value)) {
      view.removeAttribute(name);
      view[name] = false;
      delete node.attrs[name];
    } else if (value === false) {
      view.removeAttribute(name);
      view[name] = false;
      node.attrs[name] = false;
    } else {
      view.setAttribute(name, '');
      view[name] = true;
      node.attrs[name] = true;
    }
    return null;
  };

  updateClass = function(node, value) {
    if (isFunc(value)) {
      value = value();
    }
    node.attrs.className = node.view.className;
    if (node.attrs.className === value) {
      return;
    }
    if (value) {
      node.view.className = value;
      node.attrs.className = value;
    } else {
      node.view.className = void 0;
      delete node.attrs.className;
    }
    return null;
  };

  updateStyle = function(node, style) {
    var attrs, changed, css, name, prop, propMap, sobj, value, view;
    view = node.view;
    attrs = node.attrs;
    sobj = attrs.style;
    if (!view) {
      return;
    }
    if (isFunc(style)) {
      style = style();
    }
    if (isNot(style)) {
      view.style.cssText = null;
      delete attrs.style;
    } else if (isString(style)) {
      view.style.cssText = style;
      attrs.style = style;
    } else {
      css = '';
      sobj = isObject(sobj) ? sobj : {};
      changed = false;
      propMap = Object.assign({}, style, sobj);
      for (name in propMap) {
        value = style[name];
        if (value !== sobj[name]) {
          changed = true;
        }
        sobj[name] = value;
        if (isNot(value)) {
          delete sobj[name];
        } else {
          prop = normalizeName(name);
          css += prop + ': ' + value + '; ';
        }
      }
      if (changed) {
        if (css.length) {
          css = css.slice(0, -1);
          view.style.cssText = css;
          attrs.style = sobj;
        } else {
          view.style.cssText = null;
          delete attrs.style;
        }
      }
    }
    return null;
  };

  updateEvent = function(node, callback, name) {
    var events, listener, type, view;
    events = node.events || (node.events = {});
    view = node.view;
    type = normalizeEvent(name);
    listener = events[name];
    if (isString(callback)) {
      callback = node[name];
    }
    if (listener !== callback) {
      if (listener) {
        view.removeEventListener(type, listener);
        delete events[name];
      }
      if (callback) {
        view.addEventListener(type, callback);
        events[name] = callback;
      }
    }
    return null;
  };

  removeEvents = function(node) {
    var events, listener, name, type, view;
    events = node.events;
    if (!events) {
      return null;
    }
    view = node.view;
    for (name in events) {
      listener = events[name];
      type = normalizeEvent(name);
      if (listener) {
        view.removeEventListener(type, listener);
      }
      delete events[name];
    }
    node.events = null;
    return null;
  };

  updateChildren = function(node, cfgs) {
    var cfg, child, children, i, j, l, ref;
    children = node.children || (node.children = []);
    if (isFunc(cfgs)) {
      cfgs = cfgs();
    }
    cfgs = isString(cfgs) ? [cfgs] : cfgs || [];
    l = children.length > cfgs.length ? children.length : cfgs.length;
    for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      child = children[i];
      cfg = cfgs[i];
      if (isFunc(cfg)) {
        cfg = cfg();
      }
      if (!child && !cfg) {
        throw new Error(("DOM ERROR: either child or cfg at index " + i + " must be defined. Got ") + child + ', ' + cfg);
      }
      if (!child) {
        addChild(node, cfg);
      } else if (!cfg) {
        removeChild(child);
      } else {
        change(child, cfg);
      }
    }
    children.length = cfgs.length;
    return null;
  };

  change = function(node, cfg) {
    var needsUpdate;
    needsUpdate = node.updateCfg(cfg);
    if (node === cfg || node.constructor === cfg.tag) {
      if (needsUpdate) {
        updateProperties(node, node.render());
      }
    } else if (node.tag !== cfg.tag || cfg instanceof Node) {
      replaceChild(node, cfg);
    } else if (isNot(node.tag)) {
      updateText(node, cfg);
    } else if (needsUpdate) {
      updateProperties(node, cfg);
    }
    return false;
  };

  addChild = function(node, cfg) {
    var child;
    if (cfg instanceof Node) {
      child = cfg;
    } else {
      if (!cfg.__i__) {
        cfg.__i__ = node.__i__;
      }
      child = create(cfg);
    }
    child.updateNow(cfg = child.render());
    node.children.push(child);
    node.view.appendChild(child.view);
    child.parent = node;
    child.depth = node.depth + 1;
    child.onMount();
    return null;
  };

  removeChild = function(child) {
    var node, view;
    node = child.parent;
    view = child.view;
    disposeNode(child);
    node.view.removeChild(view);
    return null;
  };

  replaceChild = function(child, cfg) {
    var children, i, node, view;
    node = child.parent;
    children = node.children;
    i = children.indexOf(child);
    view = child.view;
    disposeNode(child);
    if (cfg instanceof Node) {
      child = cfg;
      cfg = child.render();
    } else {
      if (!cfg.__i__) {
        cfg.__i__ = node.__i__;
      }
      child = create(cfg);
    }
    child.updateNow(cfg = child.render());
    children[i] = child;
    child.parent = node;
    child.depth = node.depth + 1;
    node.view.replaceChild(child.view, view);
    if (isSimple(cfg) || (!cfg.tag && (isSimple(cfg.text) || isFunc(cfg.text)))) {
      updateText(child, cfg);
    } else {
      updateProperties(child, cfg);
    }
    child.onMount();
    return null;
  };

  disposeNode = function(node) {
    var child, j, len, ref;
    if (node.onUnmount() !== true) {
      removeEvents(node);
      if (node.children && node.children.length) {
        ref = node.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          disposeNode(child);
        }
      }
      delete node.children;
      delete node.view;
      delete nodeMap[node.__id__];
    }
    node.parent = null;
    node.depth = void 0;
    return null;
  };

  checkDom = function(dom) {
    if (domList.indexOf(dom) > -1) {
      throw new Error('Dom element already controlled by another node.');
    }
  };

  append = function(node, dom) {
    if (Node.CHECK_DOM) {
      checkDom(dom);
    }
    return dom.appendChild(node.view);
  };

  behind = function(node, dom) {
    var next, parent;
    parent = dom.parentNode;
    next = dom.nextSibling;
    if (Node.CHECK_DOM) {
      checkDom(parent);
    }
    if (next) {
      return parent.insertBefore(node.view, next);
    } else {
      return parent.appendChild(node.view);
    }
  };

  before = function(node, dom) {
    var parent;
    parent = dom.parentNode;
    if (Node.CHECK_DOM) {
      checkDom(parent);
    }
    return parent.insertBefore(node.view, dom);
  };

  replace = function(node, dom) {
    var parent;
    parent = dom.parentNode;
    if (Node.CHECK_DOM) {
      checkDom(parent);
      checkDom(dom);
    }
    return parent.replaceChild(node.view, dom);
  };

  remove = function(node) {
    var parent;
    parent = node.view.parentNode;
    if (Node.CHECK_DOM) {
      checkDom(parent);
    }
    return parent.removeChild(node.view);
  };

  if (typeof window !== 'undefined') {
    lastTime = 0;
    vendors = ['webkit', 'moz'];
    for (j = 0, len = vendors.length; j < len; j++) {
      vendor = vendors[j];
      if (window.requestAnimationFrame) {
        break;
      }
      window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback) {
        var currTime, id, rAF, timeToCall;
        currTime = Date.now();
        timeToCall = Math.max(0, 16 - currTime + lastTime);
        rAF = function() {
          return callback(currTime + timeToCall);
        };
        id = window.setTimeout(rAF, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
        return null;
      };
    }
  }

  if (typeof Object.assign === 'undefined') {
    Object.assign = function() {
      var args, k, key, len1, src, target;
      target = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      for (k = 0, len1 = args.length; k < len1; k++) {
        src = args[k];
        for (key in src) {
          target[key] = src[key];
        }
      }
      return target;
    };
  }

  Node.create = create;

  Node.map = map;

  Node.unmap = unmap;

  Node.append = append;

  Node.behind = behind;

  Node.before = before;

  Node.replace = replace;

  Node.remove = remove;

  Node.getOrCall = getOrCall;

  Node.isBool = isBool;

  Node.isNumber = isNumber;

  Node.isString = isString;

  Node.isObject = isObject;

  Node.isFunc = isFunc;

  Node.isDom = isDom;

  Node.isDomText = isDomText;

  Node.isNot = isNot;

  Node.isSimple = isSimple;

  Node.extendsNode = extendsNode;

  ViewTree = {
    Node: Node,
    DEFAULT_CLASS: Node,
    HANDLE_CTX: true,
    HANDLE_DATA_TREE: true,
    map: map,
    unmap: unmap,
    create: create,
    render: render,
    remove: remove,
    update: update,
    updateNow: updateNow
  };

  if (typeof module !== 'undefined') {
    module.exports = ViewTree;
  }

  if (typeof window !== 'undefined') {
    window.ViewTree = ViewTree;
  } else {
    this.ViewTree = ViewTree;
  }

}).call(this);


}
});
//# sourceMappingURL=index.pack.js.map